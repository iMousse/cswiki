import{_ as l,c as i,o as p,V as e}from"./chunks/framework.syB9hai_.js";const R=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"src/base/summarize/index.md","filePath":"src/base/summarize/index.md","lastUpdated":1733140857000}'),r={name:"src/base/summarize/index.md"},a=e('<h2 id="并发" tabindex="-1">并发 <a class="header-anchor" href="#并发" aria-label="Permalink to &quot;并发&quot;">​</a></h2><p><strong>线程与进程的区别</strong>？</p><ul><li>进程是正在运行程序的实例，进程中包含了线程，每个线程执行不同的任务。</li><li>不同的进程使用不同的存储空间，同一进程下的线程共享内存空间。</li><li>线程比进程更轻量，线程上下文的切换比进程上下文的切换要低。</li></ul><br><p><strong>并发与并行的区别</strong>？</p><ul><li>并发是同一时间应对（dealing with）多件事情的能力。一个 CPU 轮流执行多个线程，宏观上是并行，微观上是串行。</li><li>并行是同一时间处理（doing）多件事情的能力。</li></ul><p>举个例子，食堂阿姨给学生打饭。一个阿姨给两个队伍同时打饭就是并发。两个阿姨同时给两个队伍打饭就是并行。</p><br><p><strong>创建线程有哪些方式</strong>？</p><ul><li>继承 Thread 线程并重写 run 方法，调用 start 启动线程。</li><li>重写 Runnable 的 run 方法，并将 Runnable 类放入到 Thread 类中，调用 start 方法启动线程。</li><li>重写 Callable 的 call 方法，并将 Callable 放入到创建 TaskFuture 中，再将创建的 TaskFuture 类放入到 Thread 类中，调用 start 方法启动线程。并且可以通过 TaskFuture 的 get 方法获取执行结果。</li><li>通过线程池创建对象，调用 sumbit 启动线程，调用 shutdown 关闭线程。</li></ul><br><p><strong>Runnable 和 Callable 有什么区别？</strong></p><ul><li>Runnable 的 run 方法没有返回值；Callable 的 call 方法有返回值，并且是个范型，可以通过 Future、FutureTask 配合 get 方法获取异步执行的结果。此方法会阻塞主进程继续往下执行，如果不调用则不会阻塞。</li><li>Runnable 的 run 方法的异常只能在内部消化，不能向上抛，Callable 的 call 方法允许抛出异常。</li></ul><br><p><strong>run 方法和 start 方法有什么区别？</strong></p><ul><li>start 方法用来启动线程，通过线程调用 run 方法中的代码，start 方法只允许调用一次，而 run 方法封装了要执行的代码，可以多次调用。</li><li>start 方法是将线程 NEW 状态切换成 RUNNABLE 状态，调用完 run 方法后线程就从 RUNNABLE 状态切换成了 TERMINATE 状态。</li></ul><br><p><strong>线程之间的状态是如何切换的</strong>？</p><p>JDK中的 Thread 线程中有枚举类型定义了线程的六种状态，分别为：新建，运行，阻塞，等待，有限等待，终结。</p><ul><li>当一个线程对象被创建并调用了 start 方法，线程就会从 NEW 状态进入到 RUNNABLE 状态，当执行了 run 方法，线程就会从 RUNNABLE 进入 TERMINATE 状态。这是一个线程的正常的状态。</li><li>当线程获取锁失败，则会从 RUNNABLE 状态进入 Monitor 的阻塞队列进入到 BLOCK 状态，当持有线程的锁释放以后，就会按照一定的规则唤醒阻塞队列的线程，唤醒后的线程则进入可运行状态去竞争锁。</li><li>当线程获取锁成功，但是由于没有满足条件而调用了 wait 方法，就会将 RUNNABLE 的线程状态切换成 WAITING 。当持有线程的锁调用了 notify 或 notifyall 方法后就会重新竞争锁。如果是调用了带参数的 wait 方法则会在等待时间结束以后等待唤醒后去重新竞争锁。</li><li>还有一种情况就是调用了 Thread.sleep 的带参方法也会将线程从 RUNNABLE 进入 TIMED_WAITTING，并且不需要主动唤醒，时间到了以后就会自然恢复到可运行状态。</li></ul><br><p>sleep 方法和 wait 方法的相同点和不同点？</p><p>相同点</p><ul><li>sleep 方法和 wait 方法都是将线程的 RUNNABLE 状态切换成 WAITING状态</li><li>都可以清除打断状态</li></ul><p>不同点</p><ul><li>方法归属不同：sleep 方法属于 Thread 的静态方法，wait 属于 Object 的成员方法</li><li>醒来时机不同：sleep 方法和 wait 方法虽然都是等待相应的时间醒来，但是 wait 必须通过notify 进行唤醒，并且 wait 方法不唤醒就会一直等待下去，而 slepp 在等待完时间后就会自动唤醒。</li><li>锁特性不同：wait 方法调用必须获取 wait 方法的对象锁，而 sleep 方法没有这个限制。并且 wait 方法执行后释放对象锁，允许其他线程获取该对象锁。如果 sleep 在 synchronized 代码块中执行，并不会释放对象锁。</li></ul><br><p>如何终止一个正在运行的线程。</p><ul><li>使用终止标志和关键字 volatile，使线程正常退出，就是让 run 方法执行完成后终止。</li><li>使用线程的 interrupt 方法中断线程，内部其实也是使用中断标记来中断线程。</li><li>使用线程的 stop 方法强行终止，这个方法在 JDK中已经废弃，不推荐使用。</li></ul><br><p>什么是 Java 内存模型，如何理解？</p><ul><li>Java 内存模型定义了共享内存中多线程程序读写操作的行为规范，通过这些规范来对保证内存的读写操作正常执行。</li><li>Java 内存模型把内存分为私有线程的工作区域，称为工作内存；一块是所有线程的共享区域，称为主内存。</li><li>线程和线程之间的数据是相互隔离的，线程间的通信必须通过主内存。</li></ul><br><p>导致并发问题的根本原因是什么，如何解决？</p><ul><li>导致并发问题的原因有三个，线程切换带来的原子性问题，编译器优化带来的可见性问题，CPU指令重排带来的有序性问题。</li><li>可见性问题是编译器优化造成的，有序性问题是 CPU 指令重排导致的，可以使用 volatile 关键字来解决。原子性问题是切换导致的，可以使用 CAS 解决，加锁可以粗暴的解决这三种问题。</li></ul><br><p>关键字 volatile 有什么功能？</p><p>volatile 关键字可以修饰类的成员变量、类的静态成员变量。主要有两个功能</p><ul><li>保证了线程间的可见性：用 volatile 修饰共享变量，能够防止编译器优化，让一个线程对共享变量的修改对另一个线程可见。</li><li>禁止进行指令重排序：用 volatile 修饰变量，变量在读写时会加入读写屏障，阻止其他读写操作越过屏障，达到阻止重排序的效果。</li></ul><br><p>关键字 synchronized 原理是什么？</p><p>synchronized 是基于悲观锁实现的，性能比较低。依赖于 JVM 级别的 monitor，存在于每个 Java 对象的对象头中，synchronized 锁就是通过这种方式获取的，所以 Java 任意对象都可以作为锁。</p><p>monitor 内部维护了三个变量，owner 表示持有锁的线程，waitset 保存了等待状态的线程，entrylist 保存了处于阻塞状态的线程。</p><p>线程获取成功就是获取 monitor 中的 owner，并且一个 monitor 只有一个 owner，当上锁成功以后有其他的线程来争抢锁则会失败进入到 entrylist 阻塞队列。当获取锁的线程释放后，就会唤醒 entrylist 中等待的线程来竞争锁，竞争的时候是非公平的，有利于提升线程效率。在调用wait方法的线程会在 waitset 中等待，被唤醒后进入阻塞队列重新竞争锁。</p><br><p>你知道 synchronized 锁升级吗？</p><p>Java 中为了获得锁和释放锁带来的性能消耗，引入了偏向锁，轻量级锁和重量级锁。对应了只被一个线程持有、不同线程交替持有、多线程竞争三种情况。锁升级的过程是自动的，不需要开发者手动干预。</p><br><p>CAS 是什么，具体流程是怎么样的？</p><p>CAS 全程 Compare And Swap 比较在交换；体现的是一种乐观锁思想，在无锁的状态下保证线程操作数据的原子性。</p><p>我们举个例子，主内存存在一个共享变量 100。线程有两个线程，线程一将共享变量从主内存中复制一份到工作内存做 count ++ 操作，线程二将共享变量从主内存复制一份到工作内存做 count -- 操作。线程一复制到共享变量副本为 100，count ++ 以后变成了 101，这时我们将共享变量副本值与共享变量的值相等，则将共享变量的值修改为 101。线程二复制的共享变量副本也为 100，count -- 以后变为了 99，将共享变量副本与最新共享变量做对比，100 不等于 101，修改失败。这时线程二会进入自旋操作。</p><br><p>乐观锁和悲观锁的区别</p><ul><li>乐观锁是最乐观的估计，不怕别人来修改共享变量，就算修改了也没关系，可以吃亏一点重试。在竞争不激烈的时候可以提升性能。</li><li>悲观锁是最悲观的估计，防止别人来修改变量，我上了锁其他线程都不能修改，我修改成功以后其他线程才能修改。</li></ul><br><p>介绍一下 ReentranLock 和 RenntranLock 工作流程</p><p>ReentranLock 是属于并发包下的类，是API层面的锁，和 synchronized 一样都是悲观锁实现互斥。通过 lock 方法获取锁，unlock 方法释放锁。支持可重入、可中断、可超时、可以设置公平锁和多个条件变量。底层通过 CAS 和 AQS 队列实现。</p><p>ReentranLock 内部维护了 volatile 修饰的共享变量 STATE 来表示资源的状态。当线程来争抢锁后通过 CAS 的方式修改 STATE 状态，修改成功则为1，让 exclusiveOwnerThread 属性指向当前线程，获取锁成功。如果修改状态失败则会进入双向队列进行等待，Head 指向双向队列头部，Tail 指向双向队列尾部。当 exclusiveOwnerThread 为空的时候，会唤醒在双向队列中等待的线程。公平锁体现在按照先后顺序获取锁，非公平体现在不排队的线程也可以争抢锁。</p><br><p>synchronized 和 Lock 有什么区别</p><ul><li>语法层面：synchronized 是源码层上的实现，Lock 是 API 层面的实现。使用 synchronized 时，退出同步代码块会自动释放锁，Lock 需要手动调用 unlock 释放锁。</li><li>功能层面：二者虽然都是悲观锁，都具备基本的互斥、同步、锁重入。但 Lock 提供了 synchronized 不具备的可打断，锁超时，公平锁，多条件变量。Lock 还提供了 读写锁和可重入锁。</li><li>性能层面：虽然在没有竞争的情况下做了很多优化，比如偏向锁、轻量级锁，但是在竞争激烈的情况下，还是 Lock 会提供更好的性能。</li></ul><br><p>谈谈你对 ThreaLocl 的理解。</p><p>线程安全的本质是工作线程对主内存共享变量的修改。而 ThreadLocal 就是通过让每个线程只用自己的资源对象，并且在线程内资源共享。避免了因为对主内存变量的修改引发的线程安全问题。</p><p>ThreadLocal 内部维护了一个 ThreadLocalMap 类型的成员变量来存储资源对象。当调用 set 方法就将自己作为 key，资源对象作为 value，放入当前线程的 ThreadLocalMap 集合中。get 方法和 remove 方法就是通过自己作为key 来获取和删除 ThreadLocalMap 中的资源对象。</p><br><p>为什么 ThreadLocal 会导致内存溢出。</p><p>因为 ThreadLocal 中的 key 被设置成弱引用，当发生垃圾回收时 key 会获得内存释放，但是 value 值作为强引用不会被垃圾回收。所以我们在使用 ThreadLocal 的时候需要主动使用 remove 方法释放内存，避免内存溢出。</p><br><p>线程池的核心参数有哪些？</p><ul><li>核心线程数目，线程池中保留的最多线程数。</li><li>最大线程数目指的是核心线程加救济线程的最大数目。</li><li>生存时间指的是救急线程的生存时间，如果生存时间没有新任务，此线程资源就会释放。</li><li>时间单位指的是救急线程的生存时间单位。</li><li>阻塞队列，当没有空闲的核心线程时，新来的任务会加入到此队列排队，队列满了会创建急救线程执行任务。</li><li>线程工厂可以定制线程对象的创建，如设置线程名称，是否为守护线程。</li><li>拒绝策略是指当所有线程都满时，阻塞队列也放满会触发拒绝策略。 <ul><li>有四种拒绝策略：分别是抛异常，调用者执行任务，丢弃当前任务，丢弃最早的排队任务。默认是直接抛出异常。</li></ul></li></ul><br><p>线程池是如何提交任务的。</p><ul><li>任务在提交的时候，首先判断核心线程是否已经满了，如果没有满则直接加入核心线程。</li><li>如果核心线程满了，则判断阻塞队列是否已满，如果没有满，当前任务存入阻塞队列。</li><li>如果阻塞队列也满了，则判断最大线程数是否已满，如果没有满，则使用急救线程执行。</li><li>如果最大线程也满了，则走拒绝策略。</li></ul><br><p>线程池有哪些常见的阻塞队列。</p><p>常见的阻塞队列有4种，用的最多是 ArrayBlockingQueue 和 LinkedBlockingQueue</p><ul><li><code>LinkedBlockingQueue</code>：基于链表结构的阻塞队列，FIFO。默认是没有边界的，可以设置为有边界，读写各有一把锁，性能比较好</li><li><code>ArrayBlockingQueue</code>：基于数组结构的阻塞队列，FIFO。强制有边界，只有一把锁，读写共用，性能相对于 <code>LinkedBlockingQueue</code> 要差一些</li><li><code>SynchronousQueue</code>：不存储元素的阻塞队列，每个插入操作都必须等待一个移出操作。</li><li><code>DelayedWorkQueue</code> ：是一个优先级队列，它可以保证每次出队的任务都是当前队列中执行时间最靠前的</li></ul><br><p>JUC 的 Executors类中提供了哪些线程池。</p><ul><li>newFixedThreadPool：创建一个固定线程数的线程池，核心线程和最大线程数相同，没有救急线程，阻塞队列使用的是 LinkedBlockingQueue，最大容量为 Integer.MAX_VALUE。适用于任务量已知，相对耗时的任务。</li><li>newSingleThreadExecutor：核心数和最大线程数都是1，阻塞队列使用的是 LinkedBlockingQueue，最大容量为 Integer.MAX_VALUE。适用于按照顺序执行的任务。</li><li>newCachedThreadPool：核心线程为0，最大线程数为 Integer.MAX_VALUE，全是救急线程。阻塞队列为 SynchronousQueue ，不存储元素数组的阻塞队列，每次插入操作都需要等待一个移出。适用于任务比较密集，但每个任务执行时间都比较短的场景。</li><li>newScheduledThreadPool：适用于有定时和延迟执行的场景。</li></ul><p>但是不建议使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式可以让我们更加明确线程池的运行规则，避免资源耗尽的风险。比如 FixedThreadPool， SingleThreadPool 和 CachedThreadPool 允许请求队列的长度都是 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。</p><br><p>如何设置核心线程数？</p><p>我们可以把并发高低和任务执行时间的长短分为两个维度。</p><ul><li>并发低，执行时间短的我们系统是不需要优化设置的</li><li>并发高，执行时间短的我们需要减少线程上下文的切换，CPU 核心数 + 1 即可</li><li>并发低，执行时间长的我们需要判断是 IO 密集型还是计算密集型 <ul><li>IO 密集型一般是文件的读写，DB读写，网络请求，适用于 CPU 核心数 * 2 + 1</li><li>计算密集型一般是代码计算，数据转化，数据排序，适用于 CPU 核心数 + 1</li></ul></li><li>并发高，执行时间长的任务设置核心数不是重点，重点是整体架构的设计。先看看是否可以做缓存，然后是否可以增加服务器，至于线程可以按照 IO 密集型或者 CPU 密集型设置。</li></ul><br><h2 id="缓存" tabindex="-1">缓存 <a class="header-anchor" href="#缓存" aria-label="Permalink to &quot;缓存&quot;">​</a></h2><p>什么是缓存穿透，如何解决？</p><p>缓存穿透是当查询一个不存在的数据，从缓存中查不到数据，每次都去查询数据库，请求太多就会导致数据库崩溃。一般有这种情况都是数据库遭遇到了攻击，一般采用缓存空数据和布隆过滤两种方法。</p><ul><li>缓存空数据实现简单，但是会造成一定的内存浪费，还有可能会导致数据一致性问题</li><li>布隆过滤器占用内存少，没有多余的key，但是有一定的误判。</li></ul><p>布隆过滤器可以通过 Redisson 实现，实现原理是声明一个比较大的数组，里面存 0。在 Key 经过三次 hash 以后，摸于数组长度知道数组下标的数据，从 0 改到 1，三个数组位置标记一个 Key。查找过程同理。所以布隆过滤器会有一定的误判，一般将误判率设置成 5%，低于 5% 需要增加数组长度，但是会对内存产生更多的消耗。</p><br><p>什么是缓存击穿，如何解决？</p><p>缓存击穿是指一个设置过期时间到 Key，在过期时有大量的请求发送过来。这时候所有的查询都走数据库，从而导致数据库崩溃。我们一般互斥锁和逻辑过期有两种方法解决。</p><ul><li>互斥锁是在缓存失效的时候设置一个互斥锁，只有拿到互斥锁才能重建缓存，在重建缓存期间的请求都会被阻塞，只有重建完成以后才能重新获取缓存数据。</li><li>逻辑过期时给缓存设置一个逻辑过期时间，当缓存要过期时重新开启一个有互斥锁的线程对数据进行重建。在重建的过程中，新线程只能拿到过期的数据，并且因为有互斥锁的缘故，新线程不能重建数据。当数据重建完成后其他线程就能获取到最新数据。</li></ul><p>两种方法各有利弊，互斥锁保证了数据的强一致性，但是性能不高，因为缓存在重建的过程中是无法获取数据的。逻辑过期保证了高可用，性能比较高，保证了数据最终一致性，但是没有保证数据的实时一致性。</p><br><p>什么是缓存雪崩，如何解决？</p><p>缓存雪崩是指大量 Key 同一时间失效或者 Redis 服务宕机，导致大量的请求直接到达数据库，造成数据库崩溃。</p><ul><li>给不同的 Key 设置随机过期时间。</li><li>利用 Redis 集群提高服务的可用性。</li><li>给业务添加多级缓存</li><li>给缓存业务添加降级策略，降级策略作为系统的保底，适用于穿透、击穿、雪崩。</li></ul><br><p><strong>你们项目是如何将数据库和缓存数据进行同步的</strong>？</p><p>对一致性要求没那么高的，采用异步通知的方式对数据进行通过</p><ul><li>使用 MQ 作为中间件，当服务数据更新以后，通过消息更新将缓存数据更新</li><li>使用 Canal 作为中间件，不需要修改业务代码，伪装成 MySQL 的一个从节点，读取 binlog 日志来将缓存数据更新</li></ul><p>如果是强一致性的，采用 Redisson 提供的读写锁。</p><ul><li>将业务的查询添加共享锁：读锁 ReadLock，加锁后其他线程可用共享读操作。</li><li>将业务的修改添加排他锁：独占锁 WriteLock，加锁后修改会阻塞其他线程的读写操作。</li></ul><br><p>你听说过延迟双删吗，为什么不用延迟双删？</p><p>延迟双删，如果是写操作，先删除缓存中的数据，然后再修改数据库，延迟一会儿再删除缓存中的数据。其中这个延迟时间不好确定，延迟的过程中也可能会有脏数据，并不能保证强一致性。并且这样的代码编写复杂，不利于对业务代码的理解。所以我们系统没有采用。</p><br><p>你们项目中的分布式锁是如何实现的？</p><p>我们系统使用的是 Redisson 来实现分布式锁的，底层是 sentx 和 Lua 脚本来实现的。因为 Redis 是单线程的，用了命令之后只能有一个客户端对 Key 进行设置值，当 Key 没有过期或者删除，其他客户端都不能设置这个 Key。</p><br><p>Redisson 如何实现锁的有效时长？</p><p>Redisson 的锁有一个等待时间和超时时间。当一个锁设置超时时间还没有结束时，会有一个看门狗机制，每隔一段时间就会检查当前业务是否还持有锁，如果还持有锁就增加锁的持有时间，当业务执行完以后就可以直接释放了。</p><p>等待时间可以在高并发的情况下提升性能，当线程发生争抢后不会马上进入阻塞，而是进入自旋操作，尝试获取锁。当抢到的线程释放后，没有抢到的线程就可以尝试重新获取锁。</p><p>Redisson 锁还支持可重入，这是为了避免出现死锁。重入机制就是在尝试重入的时候会判断是否是当前线程持有的锁，如果是当前线程持有的锁就加一，释放锁的时候当前线程持有减一。存储线程数据是 Hash 结构，大 Key 是自己业务锁，小 Key 是线程ID，Value 是线程重入次数。</p><br><p>Redisson 实现的分布式锁能解决主从一致性问题吗？</p><p>Redisson 无法解决分布式锁的一致性问题。当线程一加锁成功后，从节点还没有从主节点获取到同步的数据就宕机了。这时候从节点就会重新升级为主节点，当这时重新进来一个线程二，就会在新的主节点上重新上锁，这时候就会有两个线程都获取到同一把锁。</p><p>Redisson 提供了红锁解决了这个问题。红锁主要提供了同时在再多个节点上都创建锁成功才能使用锁，解决了由于主从节点数据延迟同步导致的加锁失败问题。但正因为红锁需要同时在多个节点上加锁，性能就会变的很低，维护成本也很高，所以项目中一般不会使用红锁，并且官方也暂时废除了这个红锁。</p><br><p>如果业务一定要考虑数据强一致性怎么办呢？</p><p>Redis 本身设计就是高可用，做到强一致性就非常影响性能，可以考虑使用 Zookeeper 实现分布式锁来保证强一致性。</p><br><p>Redis作为缓存，如何实现数据的持久化？</p><p>Redis 持久化数据有两种方式，一种是 RDB ，一种是 AOF</p><ul><li>RDB 是快照文件，定期将内存中的数据同步到磁盘中，当 Redis 宕机需要恢复数据时则通过 RDB 快照文件进行数据恢复</li><li>AOF 是追加文件，将 Redis 执行写操作的命令追加到文件中，当 Redis 宕机需要恢复数据则通过 AOF 文件执行所有记录在文件上的写命令。</li></ul><p>RDB 是一个二进制文件，数据恢复的很快，但是会有丢失数据的风险。而 AOF 丢失数据风险比较小，有灵活的刷盘策略，但是是通过执行命令的方式，所以恢复数据比较慢。在 Redis 4.0 更新了一种混合持久化，结合了 RDB 和 AOF 文件的优点。在 AOF 文件的前半部分包含了一个完整的快照数据，在 AOF 文件的后半部分记录自生成 RDB 文件之后的所有写操作命令，用来提高数据恢复的效率和丢失数据的风险。</p><br><p>RDB 执行的原理是什么？</p><p>Redis 在执行 bgsave 命令后主进程会 fork 一个子进程来共享内存空间。</p><p>共享的内存空间是通过页表来维护的，页表是维护虚拟内存和物理内存的关系映射，所以子进程拷贝主进程的数据很快，是纳秒级别的。完成 fork 以后子进程会写新的 RDB 来替换旧的 RDB文件。</p><p>fork 采用的是 copy-on-write 技术。当线程来读取数据时，可以读取共享内存的数据。当有写操作，则将共享内存的数据拷贝一份并进行修改，修改完成以后线程则读取最新修改后的数据。</p><br><p>怎么保证 Redis 的高并发高可用？</p><p>搭建主从节点提升高并发，并使用哨兵模式提升高可用，哨兵模式可以实现主从集群的自动故障恢复，里面就包含了对主从服务的监控、自动故障转移和通知。</p><br><p>你们项目是采用什么样的集群？</p><p>我们项目当时采用的是一主两从三哨兵。一般单节点不超过10g内存，如果内存不足则可以通过给不同服务分配独立的 Redis 主从节点，尽量不做分片集群。因为分片集群维护起来比较麻烦，成本比较高，并且集群之间的心跳检测和数据通信会消耗大量的网络请求，并且不可以使用 Redis 的事物和 Lua 脚本。</p><br><p>那你们 Redis 集群脑裂是如何解决的？</p><p>当我们主节点信号不好时，哨兵没有感受到主节点的心跳，这时哨兵就会选取一个从节点来作为新的主节点，这时就存在两个主节点，就像大脑分裂一样。这样会导致客户端还在原先的主节点写数据，新节点无法同步数据。当网络恢复以后，哨兵就会将原先的主节点降为从节点，这时再从新的主节点同步数据，脑裂过程中写入的数据则都会丢失。</p><p>我们可以在 Redis 设置两个参数来解决脑裂问题。一个参数时设置最少的从节点数，必须要有一个从节点才能同步数据。第二个设置主从复制和同步的延迟时间，达不到要求的就拒绝请求，这样就可以避免数据丢失。</p><br><p>Redis 的数据过期策略有哪些？</p><p>Redis 的数据过期策略有两种，一种是惰性删除，还有一种是定时删除。</p><ul><li>惰性删除是每次查询 Key 时判断是否过期，过期则删除数据。</li><li>定时删除是定期抽样部分 Key 判断是否过期，过期则删除数据。其中定时删除还分为两种模式，SLOW 和 FAST <ul><li>SLOW 是高吞吐模式，默认每秒执行10次，每次不超过 25ms</li><li>FAST 是低延迟模式，执行的频率不固定，但两次间隔不能低于 2ms，每次耗时不能超过 1ms</li></ul></li></ul><p>Reids 的过期策略是两种结合：惰性删除加上定期删除进行配合使用。</p><br><p>Redis 的数据淘汰策略有哪些？</p><p>Redis 总共提供了八种数据淘汰策略。系统默认的数据淘汰策略是不删除任何数据，内存不足直接报错。还有一种是随机删除的数据淘汰策略。其他的配置有两个重要的概念，一个是 LRU ，一个是 LFU。</p><ul><li>LRU 是最少最近使用，用当前时间减去最后一次访问的时间，这个值越大淘汰的优先级越高。按照最少最近使用有两种数据淘汰策略，一种是所有 Key 按照 LRU 来进行淘汰，一种是只有设置了 TTL 的 Key 按照 LRU 进行淘汰。</li><li>LFU 是最少频率使用，会统计每个 Key 的访问频率，访问频率越低淘汰的优先级越高。按照最少频率使用有两种数据淘汰策略，一种是所有 Key 按照 LFU 来进行淘汰，一种是只有设置了 TTL 的 Key 按照 LFU 进行淘汰。</li></ul><p>还有两种淘汰策略就是对设置了 TTL 的 Key 进行随机淘汰，对设置了过期时间的 TTL，比较 TTL 的剩余值，TTL 越小越先被淘汰。</p><br><p>那你们系统中的数据淘汰策略是如何使用的？</p><ul><li>如果系统中没有冷热数据的区分，访问频率差别不大，则建议使用 allkeys-random，随机选择淘汰。</li><li>如果系统中有冷热数据区分，则建议使用 allkeys-lru，把最近访问的数据留在缓存中。</li><li>如果系有短时高频的数据，则使用 allkeys-lfu</li><li>如果业务中有指定的需求，置顶的数据不过期删除，则可以使用 volaitle-ttl，只对设置 TTL 的 Key 进行删除。</li></ul><br><p>Redis 是单线程的，但是为什么还那么快？</p><ul><li>Redis 是基于内存的数据库，内存的读写速度非常快。</li><li>执行命令采用单线程，避免不必要的上下文切换。</li><li>使用多路 IO 复用模型，这种技术允许单个线程同时处理多个IO操作，单个IO操作的阻塞不会影响其他IO操作。这种IO操作提高了IO操作的效率，使得 Redis 能够在高并发环境下保持高性能‌</li></ul><h2 id="虚拟机" tabindex="-1">虚拟机 <a class="header-anchor" href="#虚拟机" aria-label="Permalink to &quot;虚拟机&quot;">​</a></h2><p>JVM有什么特性？</p><p>JVM 最大的特性是跨平台，对于 C/C++ 语言来说会将源代码编译成 CPU 能够识别的机器码来执行，不同的系统需要重新编译连接。而 Java 语言通过 Javac 将源文件编译成字节码之后，可以通过不同平台的 JVM 将字节码文件实时解释成机器码文件。并且 Java 还是半编译半解释型语言。也可以通过执行引擎的编译器将热点代码进行优化，直接转变为机器码。</p><br><p>JVM实现了哪些功能？</p><ul><li>解释与运行：通过执行引擎的解释器将字节码实时解释成CPU能够执行的机器码</li><li>即时编译：通过执行引擎的编译器将热点代码进行优化，将字节码直接转化为机器码放在方法区中存储，提高执行效率。</li><li>内存管理：通过运行时数据区自动的为对象、方法分配内存空间，通过执行引擎的垃圾回收器自动实现垃圾回收。</li></ul><br><p>JVM由哪些部分组成，如何运行？</p><p>JVM 主要由类加载器，运行时数据区，执行引擎，本地库接口组成。Java 源文件通过 Javac 将源代码编译成字节码，然后通过类加载器子系统加载到内存中，然后通过运行时数据区将加载到内存中的字节码自动分配内存。通过执行引擎的解释器将字节码翻译成机器码，在交由 CPU 去执行。如果调用了 C语言，这时就需要调用本地接口。</p><br><p>请详细说明一下 JVM 运行时数据区？</p><p>运行时数据区可以分为线程共享区和线程私有区。</p><ul><li>线程共享区有堆和本地内存，堆是主要数据存储的地方，存储对象和数组。是垃圾回收器管理的主要部分。本地内存不是虚拟机运行时数据区的一部分，是虚拟机直接向系统申请的内存区域，包含了方法区和直接内存。方法区是存放类的信息，常量、方法、字段、静态变量、即时编译优化后的代码。直接内存常用于 NIO 操作，用于数据缓冲区，分配成本高但是读写性能也高。</li><li>线程私有区有虚拟机栈，本地方法栈，程序计数器。虚拟机栈是程序运行的地方，里面存储的是栈帧，栈帧里面存储的是局部变量表、操作数栈、动态链接、方法出口等。本地方法栈与虚拟机栈功能相同，区别是本地方法栈是 Java 调用非 Java 代码的接口。程序计数器存放的是当前线程所执行字节码的行数。</li></ul><br><p>能给我详细介绍一下方法区吗？</p><ul><li>方法区是各个线程共享的内存区域，与直接内存一起存储与本地内存中。</li><li>主要存储的是被虚拟机加载类的元数据信息。包括类的结构、方法、字段、常量，即时编译器优化的代码。</li><li>在 JDK7 方法区称为永久代，并且数据放在堆中，如果加载类数据太多很容易导致 OOM。在 JDK8 中就将方法区的实现放在了本地内存的元空间中，将字符串常量放入了堆中。这样元空间的大小就不受 JVM 限制，并且不需要GC，提升了性能。</li><li>如果方法区中无法存放，则会抛出 <code>OutOfMemoryError:Metaspace</code></li></ul><br><p>字符串常量池和运行时常量池有什么关系？</p><p>字符串常量池是存放于 JVM 的堆中，用于存储<mark>创建对象时</mark>的字符串的字面量引用，主要是为了避免程序<mark>在运行时</mark>创建大量内容相同的字符串对象，从而节省内存和提高性能‌。</p><p>运行时常量池是存放于方法区中，用于存储符号引用和字面量，在编译时就确认了。当类被加载到 JVM 中时，class文件中的常量池内容会被加载到运行时常量池中。</p><br><p>能给我详细介绍一下 Java 堆吗？</p><p>Java 堆是线程共享的区域，主要存储对象和数组，是垃圾回收器主要工作的地方。内存不足会报 <code>OutOfMemoryError:Java heap space</code>。</p><p>主要由年轻代和老年代构成。年轻代有伊甸园区，From区和To区，存放一些年轻的对象；老年代存放的是一些大对象或年老的对象。</p><br><p>什么是虚拟机栈</p><p>每个线程运行所需要的内存，称为虚拟机栈，遵循后进先出原则。并且每个栈由多个栈帧组成，对应着方法每次调用所占的内存，活动栈帧只有一个，对应着正在执行的方法。</p><br><p>堆和栈的主要区别是什么？</p><p>最本质的区别堆是存储单位，存储对象和数组；栈是运行单位，运行时调用局部变量和房变量。</p><p>栈的生命周期比较短，随着方法的入栈出栈终结；而堆的生命周期比较长，知道被垃圾回收器回收。</p><p>栈内存是线程私有的，堆内存是线程共享的。当栈空间不足时报 StackOverFlowError，堆内存不足时报 OutOfMemoryError</p><br><p>什么是类加载器，类加载器有哪些？</p><p>类加载器将字节码文件加载到 JVM 中，让 Java 程序能够运行起来。常见的类加载器由四个</p><ul><li>引导类加载器，是最顶级的加载器，由 C++ 编码实现，主要加载 JAVE_HOME/jre/lib 目录下的库类。</li><li>拓展类加载器，是引导类加载器的子类，由 Java 编码实现，主要加载 JAVE_HOME/jre/lib/ext 目录下的库类。</li><li>应用类加载器，是拓展类加载器的子类，由 Java 编码实现，主要加载 Classpath 下的类，也就是自己编写的 Java 类。</li><li>自定义类加载器，开发者自定义类继承 ClassLoader，实现自定义加载规则。</li></ul><br><p>什么是双亲委派机制，为什么使用这个机制？</p><p>如果一个类加载器收到了类加载的请求，首先不会自己去加载，而是把请求给父类加载器，而且每个层级的类加载器都是这个规则。所以最终类的加载都要到顶层的引导类加载器来加载，只有引导类加载不了这个加载请求，子类加载器才会尝试自己去加载。</p><p>使用双亲委派机制可以防止 Java 核心库的 API 被篡改，而且可以避免一个类被重复加载。</p><br><p>那你知道类加载器的执行过程吗？</p><p>类从加载器加载到虚拟机中，生命周期包括了加载、连接、初始化、使用、卸载。其中连接分为了验证、准备、解析。</p><p>首先将类加载到虚拟机中，然后验证来保证加载类的正确性，准备阶段为类分配内存，并设置类变量的初始值，解析阶段将类中的符号引用转化为直接引用。初始化阶段对类的静态变量和静态代码块执行初始化操作。使用就是对 new 完的类进行调用，当数据为空后没有引用关系则将类进行卸载。</p><br><p>能介绍一下垃圾回收器的主要功能吗？</p><p>垃圾回收器的主要功能是自动回收不再使用的对象，以防止内存泄露，并优化内存使用，从而保证程序稳定的运行。</p><p>基本功能</p><ul><li>内存分配：当程序创建对象时，垃圾回收器会在堆内存中找到足够的空闲空间来存储这些对象。</li><li>垃圾回收：自动检测并回收不再被程序引用的内存区域，确保系统资源有效利用，防止内存泄露。检测垃圾的算法有两种，引用器计数法和可达性分析算法，引用器计数法没法解决循环引用的依赖问题，所以 Java 使用的是可达性分析算法。</li><li>系统稳定：通过定期进行垃圾回收，避免系统长时间运行的程序占用内存时间过长导致的系统资源耗尽和性能下降问题。</li><li>简化编程：消除了手动管理内存的复杂性，使得开发者可以更专注业务逻辑实现，不需要关注内存分配和释放的细节。</li></ul><br><p>强引用，软引用，弱引用，虚引用各有什么区别？</p><ul><li>强引用是普通的引用方式，表示一个对象处于有用且必须的状态，即使内存不足也不会回收</li><li>软引用表示一个对象处于有用且非必须的状态，会在内存不足的时候进行回收。</li><li>弱引用表示一个对象处于可能有用且非必须的状态，在 GC 时就会被回收。</li><li>虚引用表示一个对象处于无用状态，任何时候都会被回收。</li></ul><br><p>垃圾回收算法有哪些？</p><p>垃圾回收算法主要包含标记清除算法，标记整理算法、复制算法、分代收集算法</p><ul><li>标记清除算法将垃圾回收分为标记阶段和清除阶段，标记阶段从根结点开始，标记所有可达对象，在清除阶段清除所有没有被标记的对象。效率高，但是有磁盘碎片，内存不连续。</li><li>标记整理算法分为标记，清除，整理三个阶段，会将标记清除后存活的对象移动到内存另一段。相比于标记清除算法，效率低，但是没有磁盘碎片，内存连续。</li><li>复制算法将内存分为两块，每次只使用一块。在垃圾回收时，将存活的独享复制到另一块内存中，然后清除当前块的内容。虽然没有磁盘随盘，但是造成了内存浪费，回收效率高于标记整理算法但是低于标记清除算法</li><li>分代收集算法根据对象的生命周期内存划分为年轻代和老年代，并根据各代的特征采用最合适的收集算法。</li></ul><br><p>详细说明一下分代收集算法？</p><p>JDK8版本时，堆被分为了两个部分，一个是新生代，一个是老年代，默认空间占用比例是1:2</p><p>新生代内部又被分为三个区域。伊甸园区，FROM区和TO区。默认空间占比为8:1:1</p><p>具体的工作流程是这样的：</p><ul><li>新创建的对象先放到伊甸园区，当伊甸园区和 FROM 区满时会触发 YoungGC，将存活对象采用复制算法复制到 TO区 并年龄加一，复制完成后伊甸园区和FROM区都会释放内存，并把TO 区改为FROM 区。</li><li>当经过一段时间内存又不足时触发 YoungGC，重复上面的步骤，当TO 区存活的对象超过15岁后则晋升为老年代。如果幸存区内存不足或大对象会提前晋升为老年代。</li><li>当老年代满了以后会触发FullGC，同时收集年轻代和老年代，这时是只存在FullGC的线程执行，其他线程都会被挂起。我们需要在程序中尽量避免FullGC出现。</li></ul><br><p>垃圾回收器有哪些，你们项目时如何选择的？</p><p>垃圾回收器按照工作模式划分可以分为串行垃圾回收器，并行垃圾回收器，并发垃圾回收器。</p><ul><li>串行垃圾回收器：Serial 用于新生代，使用复制算法。Serial Old 作用于老年代，采用标记整理算法。在垃圾回收时，只有一个线程在工作，其他线程都需要停下来等待垃圾回收的完成（STW）。适用于内存堆比较小的个人电脑，是 JDK 在 Client 模式下默认使用的垃圾回收器。</li><li>并行垃圾回收器：Parallel Scavenge 作用于新生代，采用复制算法。Parallel Old 作用于老年代，采用标记整理算法。在垃圾回收时，有多个线程在工作，并且其他线程都需要停下来等待垃圾回收的完成。是吞吐量优先的收集器，是 JDK在 Server 模式下默认使用的垃圾回收器。</li><li>并发垃圾回收器：Parallel New 作用于新生代，采用复制算法。CMS 作用于老年代，采用Serial Old作为备用，采用标记清除算法。是一款响应时间优先的收集器，停顿时间短，用户体验好。但是由于无法处理浮动垃圾，所以需要使用 Seiral Old 作为备用。并且由于浮动垃圾的存在，还会导致频繁的 Full GC，从而导致更大的时间停顿。从 JDK9 开始将 CMS 标记为过时，并且默认使用了 G1 垃圾回收器。</li></ul><h2 id="数据库" tabindex="-1">数据库 <a class="header-anchor" href="#数据库" aria-label="Permalink to &quot;数据库&quot;">​</a></h2><p>如何选择存储引擎？</p><ul><li>InnoDB：是 MySQL 的默认存储引擎，支持事务和外键。如果对事务的完整性有比较高的要求，并且需要在并发的情况下要求数据的一致性，数据除了插入和查询还有很多的更新删除操作，选择 InnoDB 比较合适。</li><li>MyISAM：如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务完整性、并发性要求不高，可以选择 MyISAM。</li><li>Memory：将所有数据保存在内存中，访问速度快，通常用于临时表和缓存。但对表的大小由限制，太大的表无法缓存在内存中，而且没法保证数据的安全性。</li></ul><br><p>InnoDB 引擎和 MyISAM 引擎的区别</p><ul><li>InnoDB 引擎支持事务和外键，而 MyISAM 引擎不支持事务和外键。</li><li>InnoDB 引擎有表锁和行锁，而 MyISAM 引擎只有表锁。</li></ul><br><p>什么是索引？</p><p>索引是帮助数据库快速获取数据的数据结构。通过索引可以直接查询到数据而不用进行全表扫描，提高数据查询效率，降低数据 IO 成本；通过索引对数据排序可以降低数据排序的成本，降低 CPU 的消耗。</p><br><p>索引底层数据了解过吗？</p><p>MySQL 默认存储引擎 InnoDB 采用的是 B + 树的数据结构来存储索引。B + 树相比于二叉树，层级更少，而且不会造成数据倾斜而退化成链表的情况。相比于 B - 树 ，B + 树磁盘读写效率更高，叶子节点存储索引和数据，非叶子节点存储索引和指针。相比于 Hash 索引，B + 树支持范围查询和排序。</p><br><p>B - 树和 B + 树的区别是什么？</p><ul><li>在查询的时候 B + tree 查找效率更稳定。B - tree 非叶子节点和叶子节点都会存储数据，而 B + tree 所有的数据只存储在叶子节点上。</li><li>在进行范围查询的时候 B + 树的效率更高，因为B + 树的数据都在叶子节点上存储，并且叶子节点是一个双向链表。</li></ul><br><p>什么是聚簇索引，什么是非聚簇索引？</p><ul><li>聚簇索引主要是数据和索引放在一起，B + 树的叶子节点保存了整行数据，并且只有一个，一般情况下主键作为聚簇索引。</li><li>非聚簇索引是数据和索引分开存储，B + 树的叶子节点保存了对应的主键，可以有多个。一般自己定义的索引都是非聚簇索引。</li></ul><br><p>什么是回表查询？</p><p>通过二级索引（非聚簇索引）找到对应的主键值，然后通过主键值找到聚簇索引中所对应的整行数据，这个过程称为回表查询。</p><br><p>什么是索引覆盖？</p><p>当我们使用 select 查询语句使用了索引，并且返回的列能够在索引中全部找到。</p><ul><li>当我们使用主键进行查询，会直接走聚簇索引进行查询，一次索引扫表，直接返回数据，性能高。</li><li>当我们使用非聚簇索引查询数据时，返回的列中没有创建索引，就会通过非聚簇索引查找到对应的主键值，尽量避免产生回表查询。</li></ul><br><p>什么是索引下推</p><p>索引下推是一种数据库查询优化技术，将数据过滤下推到存储引擎层面进行处理，从而减少不必要的数据传输和读取。比如当我们用户信息，我们将名称和年龄作为联合索引进行查询，name like ‘郑%’ and age = 20.当我们没有用索引下推时，存储引擎会先查询出以郑开头的数据，再通过回表查询去查询满足年龄为20岁的用户。而使用索引下推，就可以在回表之间就将联合索引的条件都满足，这样就能减少回表查询的次数。减少了数据读取，提高了查询效率。</p><br><p>MySQL 有哪些锁？</p><ul><li>按照锁的机制可以分为悲观锁和乐观锁。</li><li>按照锁的兼容性可以分为共享锁和互斥锁。</li><li>按照锁的颗粒度可以分为全局锁，表锁和行锁。</li></ul><br><p>元数据锁是什么？</p><p>元数据锁主要是维护表元数据的一致性。当一张表进行增删改查的时候，加入元数据共享锁，对表结构的查询共享，对表结构修改互斥。当对表结构进行变更时，加入元数据排他锁，不让增删改查影响到元数据的变更，保证了数据的正确性。</p><br><p>意向锁是什么？</p><p>意向锁是为了支持 InnoDB 的多颗粒度，解决表锁和行锁共存的问题。主要是为了避免在增删改查执行时，加的行锁于表锁冲突。如果没有意向锁，我们需要在便利表中所有的数据行来判断是否有行锁。有了意向锁这个表级锁之后，我们直接判断是否有意向锁就知道数据行是否被锁定。</p><br><p>InnoDB 中的行锁是如何实现的？</p><p>一个查询的事物，查询条件为大于等于19，如果有ID为19的数据，则会对19这条数据加上行锁，大于19的数据加上临键锁。行锁加上临键锁的集合就是临键锁。当其他事物在查询的时候不会阻塞，执行增删改查语句不在临键锁范围内也不会阻塞。但要修改临键锁的范围则会阻塞，只有事物在提交之后才可以执行。如果19的数据不存在，则会优化为间隙锁，不带条件查询则会升级为表锁。</p><br><p>InnoDB 的存储结构你了解吗</p><p>InnoDB 的存储结构由表空间，段，区，页和行组成。</p><ul><li>表空间是 InnoDB 结构的最高层，一个 MySQL 有多个表空间，用于存储记录和索引等数据</li><li>段分为数据段、索引段、回滚段。 InnoDB 是索引组织表，其中的数据段就是 B+ 树叶子节点，索引段为 B + 树段非叶子节点。段用来管理多个区。</li><li>区是表空间的单元结构，每个分区大小为 1MB。每个分区下有 64个连续的页，每个页大小为 16K。为了保证页数据的连续性，InnoDB 每次从磁盘会申请 4-5个区。</li><li>InnoDb 数据是按照行存储的。在行中会有两个隐藏字段 <ul><li>Trx_id：每次对某条记录进行改动时，都会把对应的事务id赋值给trx_id隐藏列。</li><li>Roll_pointer：每次对某条引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</li></ul></li></ul><br><p>事务的特性是什么？</p><p>ACID，分别是原子性，一致性，隔离性，持久性。我举个例子</p><ul><li>A 向 B 转账 500，转账成功， A 扣除 500，B 增加 500 。原子性体现在要么都成功，要么都失败</li><li>一致性体现在在转账的过程中，数据要一直。A 扣除了 500，B 必须增加 500 。</li><li>隔离性体现在在转账的过程中，A 向 B 转账不能受其他事物的干扰</li><li>持久性体现在事务在提交之后，要把数据持久化。</li></ul><br><p>并发事务带来哪些问题？</p><ul><li>脏读：一个事务读到另一个事务还没有提交的事务。</li><li>不可重复读：一个事务先后读取同一条事务，但两次读取的数据不同。</li><li>幻读：事务还没有提交之前第一次查询的数据和第二次查询的数据结果集不同。</li></ul><br><p>如何解决这些问题？</p><p>解决方案是对事务进行隔离。MySQL支持四种隔离级别。读未提交 （RU） 解决不了任何问题。串行化可以解决前面的所有问题，但是性能很低。读已提交 （RC）能解决脏读的问题，可重复读 （RR）可以解决脏读，不可重复读和幻读问题，但是当快照读和当前读一起使用的时候会有幻读问题，这也是MySQL 的默认隔离级别。</p><br><p>什么是快照读和当前读</p><ul><li>快照读：简单的 select 就是快照读，读取的是数据的可见版本，有可能是历史数据。并且在每个隔离级别下读取的数据是不同的。读已提交读取的是其他事务提交以后的数据，可重复读每次查询的都是第一次查询的数据。所以在快照读的情况下解决了幻读的问题。</li><li>当前读：读取的是数据库的最新数据，读取时还要保证其他并发事务不能修改当前记录，会对读取的数据加锁。我们常用的 select for update ，update，insert，delete 就是当前读。</li></ul><br><p>MySQL 是如何解决幻读问题的？</p><ul><li>在快照读的情况下，MySQL 是通过 MVCC 来解决幻读问题的</li><li>在当前读的情况下，MySQL 是通过临键锁来解决的。临键锁是行锁与间隙锁的结合。</li></ul><br><p>事务的实现原理是什么？</p><p>重做日志保证了事务的持久性，回滚日志保证了事务的原子性和一致性。MVCC 和锁保证了事务的隔离性。</p><ul><li>重做日志（redo log）：采用了 WAL 技术，先写日志，在写磁盘，只有日志写成功了才会提交事物。这里的日志就是 redo log。当发生宕机数据未刷新的到磁盘后，就通过 redo log 来恢复数据。</li><li>回滚日志（undo log）：回滚日志可以认为当执行一条 delete 语句时，undo log 会记录一条对应的 insert 记录；当执行一条 update 语句则会记录一条相反的 update 语句。当执行 rollback 时就可以通过 undo log 的逻辑记录并进行回滚。</li><li>MVCC 是通过数据库中的隐式字段、undo log 和 readView 实现的。</li></ul><br><p>redo log 和 undo log 区别</p><ul><li>redo log 是物理日志，记录的是物理页的变化，服务宕机用来进行对数据的同步。</li><li>undo log 是逻辑日志，当事务回滚时，通过逆操作恢复原来的数据。</li></ul><br><p>事务中的隔离性是如何保证？</p><p>事务的隔离性是由 MVCC 和锁保证的。MVCC 保证了快照读的事务隔离性，维护了一个数据的多个版本。它的底层实现主要分为了三个部分，第一个是隐藏字段，第二个是 undo log ，第三个是 readView 读视图。</p><p>MySQL 给每个表都设置了隐藏字段。一个每次操作都会自增的事务id，一个指向上一个事务的回滚指针。undo log 通过记录回滚数据，存储老版本数据，在内部形成一个版本链，在多个事务并行操作某一行记录时，会记录不同事务修改数据的版本，并通过回滚指针形成一个链表。通过 ReadView 解决一个事务查询的版本问题，并且不同隔离级别下访问的结果不同。在 RC 隔离级别下快照读读取的是事务每次提交的数据，RR 隔离级别下每次查询的都是第一次查询的数据。</p><h2 id="框架" tabindex="-1">框架 <a class="header-anchor" href="#框架" aria-label="Permalink to &quot;框架&quot;">​</a></h2><p>Spring 框架中的单例 Bean 是线程安全的吗？</p><p>不是线程安全的，Spring 中有个 @Scope 注解，默认是单例的。当 Spring 的 Bean 对象是无状态的对象，则是线程安全的，如果 Bean 中定义了可修改的成员变量，则需要考虑线程安全问题。可以改变 @Scope 注解，声明为多例模式；或者对共享变量加锁解决，或者使用 ThreadLocal 让每个线程都有自己独立的副本；使用一些线程安全的数据结构。</p><br><p>Spring Bean 的生命周期</p><p>Spring 中的循环引用</p><br><p>什么是 AOP，你们项目中使用到了 AOP 吗？</p><p>AOP 是面向切面编程。将那些与业务没有关系，但对多个对象产生影响的行为抽取为公共模块来进行复用。</p><p>我们系统中的日志文件，菜单权限，字典翻译，缓存处理等等都是通过 AOP 来进行实现的。通过切点表达式获取日志记录的方法，然后通过环绕通知获取请求方法的参数。比如类信息，方法、注解、请求方式等，获取这些参数以后保存到数据库。</p><br><p>Spring 中的事务是如何实现的？</p><p>Spring 提供了多种事务管理方式，主要包括编程式事务管理、声明式事务管理。</p><p><strong>编程式事务管理</strong>：通过编程的方式管理事务，即通过编程方式在代码中显式地声明事务的开始、提交及回滚。</p><p><strong>声明式事务管理</strong>：通过 AOP 特性，对事务的管理通过注解或者配置文件的方式进行声明，从而使事务管理成为语言无关的行为。</p><br><p>Spring 中有哪些事务传播行为？</p><p>当一个事务方法被另一个事务方法调用时，这个事务方法应该如何进行。 正常来说有几种解决方案：</p><ol><li>融入事务：直接去掉serviceB中关于开启事务和提交事务的begin和commit，融入到serviceA的事务中。问题：B事务的错误会引起A事务的回滚。</li><li>挂起事务：如果不想B事务的错误引起A事务的回滚，可以开启两个连接，一个执行A一个执行B，互不影响，执行到B的时候把A挂起新起连接去执行B，B执行完了再唤醒A执行。</li><li>嵌套事务：MySQL中可以通过给B事务加savepoint和rollback去模拟嵌套事务，把B设置成伪事务。B 事务失败只会影响自己，但 A 事务失败会都回滚。</li></ol><p>Spring 中的事务传播行为</p><ul><li>PROPAGATION_REQUIRED（需要）：A如果存在事务，则B融入A事务，A如果没有事务，则B自己开启一个事务，适用于大部分的修改操作使用</li><li>PROPAGATION_SUPPORTS（支持）：A如果存在事务，则B融入A事务，A如果没有事务，则B非事务运行，适用于大部分的查询操作</li><li>PROPAGATION_MANDATORY（强制性）：A如果有事务，则B融入A事务，A如果没有事务，则B抛出异常。</li><li>PROPAGATION_REQUIRES_NEW（需要新的）：不管 A 有没有事务，都会开启一个新的事务。</li><li>PROPAGATION_NOT_SUPPORTED（不支持）：A 没有事务则 B 以没有事务的方式运行。如果A有事务，则把A事务挂起，B以非事务的方式运行。</li><li>PROPAGATION_NEVER（从不）：如果 A 没有事务则正常运行，A有事务则 B 事务抛出异常。</li><li>PROPAGATION_NESTED（嵌套的）：如果 A 有事务则 B 以嵌套事务的方式运行。如果 A 没有事务则 B自己开启一个事务。</li></ul><br><p>Spring 事务失效有哪些场景</p><p>因为事务是由 Spring 的 AOP 动态代理来实现的，如果类没有被 Spring 管理，就不能使用Spring 的事务，如果事务不是 public 修饰则无法进行动态代理，如果是非事务方法调用事务方法，则拿到的类不是动态代理类，也无法使用 Spring 事务。</p><p>还有一种情况是 Spring 没有感受到异常或者异常类型和事务声明的异常不符合，事务也会失效。</p><p>还有一种情况是事务传播行为不对，比如在子事务中使用了 REQUIRES_NEW 的事务传播行为，则会在子事务中开启一个新的事务，则子事务的报错，原先事务是不会回滚的，因为不在一个事务中。</p>',324),o=[a];function n(u,t,s,d,c,b){return p(),i("div",null,o)}const B=l(r,[["render",n]]);export{R as __pageData,B as default};
