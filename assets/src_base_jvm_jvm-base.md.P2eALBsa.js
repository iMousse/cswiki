import{_ as a,c as t,o as e,V as r}from"./chunks/framework.syB9hai_.js";const o="/cswiki/assets/20240209104911479.Tlwi4CkS.png",l="/cswiki/assets/20240209104911557.BB0nVFFg.png",i="/cswiki/assets/20240209104911575.TZqAIdUs.png",s="/cswiki/assets/20240209104911558.GqndsSeo.png",d="/cswiki/assets/20240209104911800.hrWah-hO.png",p="/cswiki/assets/20240209104911713.8VAFZXjk.png",k=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"src/base/jvm/jvm-base.md","filePath":"src/base/jvm/jvm-base.md","lastUpdated":1730648753000}'),n={name:"src/base/jvm/jvm-base.md"},h=r('<nav class="table-of-contents"><ul><li><a href="#jvm入门">JVM入门</a><ul><li><a href="#什么是jvm">什么是JVM</a></li><li><a href="#jvm的功能">JVM的功能</a><ul><li><a href="#解释和运行">解释和运行</a></li><li><a href="#内存管理">内存管理</a></li><li><a href="#即时编译">即时编译</a></li></ul></li><li><a href="#常见的jvm">常见的JVM</a><ul><li><a href="#java虚拟机规范">Java虚拟机规范</a></li><li><a href="#java虚拟机规范-1">Java虚拟机规范</a></li><li><a href="#hotspot的发展历程">HotSpot的发展历程</a></li></ul></li></ul></li></ul></nav><h2 id="jvm入门" tabindex="-1">JVM入门 <a class="header-anchor" href="#jvm入门" aria-label="Permalink to &quot;JVM入门&quot;">​</a></h2><h3 id="什么是jvm" tabindex="-1">什么是JVM <a class="header-anchor" href="#什么是jvm" aria-label="Permalink to &quot;什么是JVM&quot;">​</a></h3><p>JVM 全称是 <code>Java Virtual Machine</code>，中文译名 Java 虚拟机。JVM 本质上是一个运行在计算机上的程序，他的职责是运行Java字节码文件。</p><p>Java源代码执行流程如下：</p><p><img src="'+o+'" alt="img" loading="lazy"></p><p>分为三个步骤：</p><ul><li>编写 Java 源代码文件。</li><li>使用 Java 编译器（javac命令）将源代码编译成 Java 字节码文件。</li><li>使用 Java 虚拟机加载并运行Java 字节码文件，此时会启动一个新的进程。</li></ul><br><h3 id="jvm的功能" tabindex="-1">JVM的功能 <a class="header-anchor" href="#jvm的功能" aria-label="Permalink to &quot;JVM的功能&quot;">​</a></h3><blockquote><p>💡 思考：JVM主要实现了哪些功能</p></blockquote><br><h4 id="解释和运行" tabindex="-1">解释和运行 <a class="header-anchor" href="#解释和运行" aria-label="Permalink to &quot;解释和运行&quot;">​</a></h4><p>对字节码文件中的指令，实时的解释成机器码，让计算机执行。</p><p>字节码文件中包含了字节码指令，计算器无法直接执行，Java虚拟机会将字节码文件中的字节码指令实时地解释成机器码，机器码是计算机可以运行的指令。</p><p><img src="'+l+'" alt="img" loading="lazy"></p><br><h4 id="内存管理" tabindex="-1">内存管理 <a class="header-anchor" href="#内存管理" aria-label="Permalink to &quot;内存管理&quot;">​</a></h4><ul><li>自动为对象、方法等分配内存</li><li>自动的垃圾回收机制，回收不再使用的对象</li></ul><p>Java虚拟机会帮助程序员为对象分配内存，同时将不用的对象使用垃圾回收器回收掉，这是对比C和C++这些语言的一个优势。在C/C++语言中，对象的回收需要程序员手动去编写代码完成，如果遗漏了这段删除对象的代码，这个对象就会永远占用内存空间，不会再回收。所以JVM的这个功能降低了程序员编写代码的难度。</p><br><h4 id="即时编译" tabindex="-1">即时编译 <a class="header-anchor" href="#即时编译" aria-label="Permalink to &quot;即时编译&quot;">​</a></h4><p>对热点代码进行优化，提升执行效率。即时编译可以说是提升Java程序性能最核心的手段。</p><br><blockquote><p>思考：为什么 Java 性能低</p></blockquote><p>Java 语言如果不做任何的优化，性能其实是不如 <code>C/C++</code> 语言的。主要原因是：</p><p>在程序运行过程中，Java 虚拟机需要将字节码指令实时地解释成计算机能识别的机器码，这个过程在运行时可能会反复地执行，所以效率较低。</p><p><img src="'+i+'" alt="img" loading="lazy"></p><p><code>C/C++</code> 语言在执行过程中，只需要将源代码编译成可执行文件，就包含了计算机能识别的机器码，无需在运行过程中再实时地解释，所以性能较高。</p><p><img src="'+s+'" alt="img" loading="lazy"></p><p>Java 为什么要选择一条执行效率比较低的方式呢？主要是为了实现跨平台的特性。Java 的字节码指令，如果希望在不同平台（操作系统+硬件架构），比如在 Windows 或者 Linux上运行。可以使用同一份字节码指令，交给 Windows 和 Linux 上的 Java 虚拟机进行解释，这样就可以获得不同平台上的机器码了。这样就实现了 <code>Write Once,Run Anywhere</code> 编写一次，到处运行的目标。</p><p><img src="'+d+'" alt="img" loading="lazy"></p><p>但是 <code>C/C++</code> 语言，如果要让程序在不同平台上运行，就需要将一份源代码在不同平台上分别进行编译，相对来说比较麻烦。</p><p>再回到即时编译，在 <code>JDK1.1</code> 的版本中就推出了即时编译去优化对应的性能。</p><p><img src="'+p+'" alt="img" loading="lazy"></p><p>虚拟机在运行过程中如果发现某一个方法甚至是循环是热点代码（被非常高频调用），即时编译器会优化这段代码并将优化后的机器码保存在内存中，如果第二次再去执行这段代码。Java 虚拟机会将机器码从内存中取出来直接进行调用。这样节省了一次解释的步骤，同时执行的是优化后的代码，效率较高。</p><p>Java 通过即时编译器获得了接近 <code>C/C++</code> 语言的性能，在某些特定的场景下甚至可以实现超越。</p><h3 id="常见的jvm" tabindex="-1">常见的JVM <a class="header-anchor" href="#常见的jvm" aria-label="Permalink to &quot;常见的JVM&quot;">​</a></h3><h4 id="java虚拟机规范" tabindex="-1">Java虚拟机规范 <a class="header-anchor" href="#java虚拟机规范" aria-label="Permalink to &quot;Java虚拟机规范&quot;">​</a></h4><ul><li>《Java虚拟机规范》由Oracle制定，内容主要包含了Java虚拟机在设计和实现时需要遵守的规范，主要包含class字节码文件的定义、类和接口的加载和初始化、指令集等内容。</li><li>《Java虚拟机规范》是对虚拟机设计的要求，而不是对Java设计的要求，也就是说虚拟机可以运行在其他的语言比如Groovy、Scala生成的class字节码文件之上。</li><li>官网地址：<a href="https://docs.oracle.com/javase/specs/index.html" target="_blank" rel="noreferrer">https://docs.oracle.com/javase/specs/index.html</a></li></ul><p><a href="./">eclipse-openj9/openj9: Eclipse OpenJ9: A Java Virtual Machine for OpenJDK that&#39;s optimized for small footprint, fast start-up, and high throughput. Builds on Eclipse OMR (https://github.com/eclipse/omr) and combines with the Extensions for OpenJDK for OpenJ9 repo.</a></p><h4 id="java虚拟机规范-1" tabindex="-1">Java虚拟机规范 <a class="header-anchor" href="#java虚拟机规范-1" aria-label="Permalink to &quot;Java虚拟机规范&quot;">​</a></h4><p>平时我们最常用的，就是Hotspot虚拟机。</p><table><thead><tr><th>名称</th><th>作者</th><th>支持版本</th><th>Github Star</th><th>特性</th><th>适用场景</th></tr></thead><tbody><tr><td>HotSpot (Oracle JDK版)</td><td>Oracle</td><td>所有版本</td><td>高(闭源)</td><td>使用最广泛，稳定可靠，社区活跃JIT支持Oracle JDK默认虚拟机</td><td>默认</td></tr><tr><td><a href="https://github.com/openjdk/jdk" target="_blank" rel="noreferrer">HotSpot (Open JDK版)</a></td><td>Oracle</td><td>所有版本</td><td>中(16.1k)</td><td>同上开源，Open JDK默认虚拟机</td><td>默认对JDK有二次开发需求</td></tr><tr><td><a href="https://github.com/oracle/graal" target="_blank" rel="noreferrer">GrallVM</a></td><td>Oracle</td><td>11, 17,19企业版支持8</td><td>高（18.7k）</td><td>多语言支持高性能、JIT、AOT支持</td><td>微服务、云原生架构需要多语言混合编程</td></tr><tr><td><a href="https://github.com/dragonwell-project/dragonwell8" target="_blank" rel="noreferrer">Dragonwell JDK龙井</a></td><td>Alibaba</td><td>标准版 8,11,17扩展版11,17</td><td>低(3.9k)</td><td>基于OpenJDK的增强高性能、bug修复、安全性提升JWarmup、ElasticHeap、Wisp特性支持</td><td>电商、物流、金融领域对性能要求比较高</td></tr><tr><td><a href="https://github.com/eclipse-openj9/openj9" target="_blank" rel="noreferrer">Eclipse OpenJ9 (原 IBM J9)</a></td><td>IBM</td><td>8,11,17,19,20</td><td>低(3.1k)</td><td>高性能、可扩展JIT、AOT特性支持</td><td>微服务、云原生架构</td></tr></tbody></table><br><h4 id="hotspot的发展历程" tabindex="-1">HotSpot的发展历程 <a class="header-anchor" href="#hotspot的发展历程" aria-label="Permalink to &quot;HotSpot的发展历程&quot;">​</a></h4><p><strong>初出茅庐 - 1999年4月</strong></p><p>源自 1997 年收购的 SmallTalk 语言的虚拟机，HotSpot 虚拟机初次在 JDK 中使用。在JDK1.2中作为附加功能存在，</p><p>JDK1.3之后作为默认的虚拟机。</p><br><p><strong>野蛮生长 - 2006年12月</strong></p><p>JDK6 发布，并在虚拟机层面做了大量的优化，这些优化对后续虚拟机的发展产生了深远的影响。</p><br><p><strong>稳步前进 - 2009-2013</strong></p><p>JDK7 中首次推出了G1垃圾收集器。收购了 Sun 公司之后，吸纳了 JRockIt 虚拟机的一些设计思想，JDK8 中引入了 JMC 等工具，去除了永久代。</p><br><p><strong>百家争鸣 - 2018-2019</strong></p><p>JDK11 优化了 G1 垃圾收集器的性能,同时推出了 ZGC 新一代的垃圾回收器，JDK12 推出 Shenan-doah 垃圾回收器。</p><br><p><strong>拥抱云原生 - 2019-至今</strong></p><p>以 Hotspot 为基础的 GraalVM 虚拟机诞生，不仅让解决了单体应用中多语言整合的难题，同时也提升了这些语言运行时的效率。极高的性能、极快的启动速度也更适用于当下的云原生架构。</p>',61),c=[h];function J(m,v,u,b,g,f){return e(),t("div",null,c)}const j=a(n,[["render",J]]);export{k as __pageData,j as default};
