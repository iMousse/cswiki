import{_ as e,E as p,c as h,m as i,a as s,J as l,w as t,V as n,o as r}from"./chunks/framework.syB9hai_.js";const R=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"src/project/redis/12-Redis原理-数据结构.md","filePath":"src/project/redis/12-Redis原理-数据结构.md","lastUpdated":1730648753000}'),c={name:"src/project/redis/12-Redis原理-数据结构.md"},g=n(`<nav class="table-of-contents"><ul><li><a href="#数据结构">数据结构</a><ul><li><a href="#sds">SDS</a></li><li><a href="#intset">IntSet</a><ul><li><a href="#intset升级">IntSet升级</a></li><li><a href="#insert新增流程">Insert新增流程</a></li><li><a href="#insert升级流程">Insert升级流程</a></li></ul></li><li><a href="#dict">Dict</a><ul><li><a href="#dict的扩容">Dict的扩容</a></li><li><a href="#dict的收缩">Dict的收缩</a></li><li><a href="#dict的rehash">Dict的rehash</a></li></ul></li><li><a href="#ziplist">ZipList</a><ul><li><a href="#ziplistentry">ZipListEntry</a></li><li><a href="#encoding编码">Encoding编码</a></li><li><a href="#连锁更新问题">连锁更新问题</a></li></ul></li><li><a href="#quicklist">QuickList</a></li><li><a href="#skiplist">SkipList</a></li><li><a href="#redisobject">RedisObject</a><ul><li><a href="#redis的编码方式">Redis的编码方式</a></li><li><a href="#五种数据结构">五种数据结构</a></li></ul></li><li><a href="#五种数据结构-1">五种数据结构</a><ul><li><a href="#string">String</a></li><li><a href="#list">List</a></li><li><a href="#set">Set</a></li><li><a href="#zset">ZSet</a></li><li><a href="#hash">Hash</a></li></ul></li></ul></li></ul></nav><br><div class="tip custom-block"><p class="custom-block-title">🔖 数据结构总结</p><p>SDS 产生的原因</p><ul><li>C 语言中的字符串获取长度需要运算，时间复杂度为 O(n)</li><li>字符中不能包含特殊字符，非二进制安全，需要通过结束标识读取数据。</li><li>一旦声明不可修改</li></ul><br><p>SDS 的特性</p><ul><li>获取字符串长度的时间复杂度为 O(1)</li><li>二进制安全，可以存放特殊标识。<strong>因为是按照长度读取数据，而不是按照结束标识读取数据。</strong></li><li>支持动态扩容，减少分配内存次数</li></ul><br><p>Intset 可以看做是特殊的整数数组，具备一些特点</p><ul><li>Redis 会确保 Intset 中的元素唯一、有序</li><li>具备类型升级机制，可以节省内存空间</li><li>底层采用二分查找方式来查询</li></ul><br><p>Dict 的特性</p><ul><li>类似 Java 的 HashTable，底层是数组加链表来解决哈希冲突</li><li>Dict 包含两个哈希表，ht[0] 平常用，ht[1] 用来 rehash</li></ul><br><p>Dict 的伸缩</p><ul><li>判断第一个哈希表 （dict.ht[0]） 的负载因子（LoadFactor = used / size）是否大于等于 1 并且没有后台进程，或负载因子大于 5，则扩容；若负载因子小于 0.1 则缩容。</li><li>如果扩容，则新 size 为第一个大于等于 used + 1 的 2^n^；如果缩容，则新 size 为小于等于 used 的 2^n^(最小为4)。并按照新的 size 申请内存空间，创建 dictht，并赋值给 dict.ht[1] <ul><li>举例：如果原先 size 为 4，used 为 5，则新 size 扩容为 8；如果原先 size 为 10，used 为 1，则新 size 缩容为 4；</li></ul></li><li>设置 dict.rehashidx = 0，标记开始 rehash。将 dict.ht[0] 中的每一个 dictEntry 都 rehash 到 dict.ht[1]。</li><li>将 dict.ht[1] 赋值给 dict.ht[0]，给 dict.ht[1] 初始化为空哈希表，并将 rehashidx 赋值为 -1，代表 rehash 结束。 <ul><li>rehash 是一个渐进式的 rehash。因为如果 Dict 包含数据量过多的 entry，要在一次 rehash 完成则极有可能造成主线程阻塞；所以 Dict 的 rehash 是分多次、渐进式完成。</li><li>rehash 过程中的新增操作直接写入 ht[1]，查询、修改和删除则会在 ht[0] 和 ht[1] 依次查找并执行。保证 ht[0] 只减不增，随着 rehash 最终结束。</li></ul></li></ul><br><p>ZipList 的特点</p><ul><li>压缩列表的可以看做一种连续内存空间的&quot;双向链表&quot;</li><li>列表的节点之间不是通过指针连接，而是记录上一节点和本节点长度来寻址，内存占用较低</li><li>如果列表数据过多，导致链表过长，可能影响查询性能</li><li>增或删较大数据时有可能发生连续更新问题，ListPack 解决了连续更新问题</li></ul><br><p>QuickList 的特点</p><ul><li>节点为 ZipList 的双端链表</li><li>节点采用 ZipList，解决了传统链表的内存占用问题</li><li>控制了 ZipList 大小，解决连续内存空间申请效率问题</li><li>中间节点可以压缩，进一步节省了内存</li></ul><br><p>SkipList 的特点</p><ul><li>跳跃表是一个双向链表，每个节点都包含 score 和 ele 值</li><li>节点按照 score 值排序，score 值一样则按照 ele 字典排序</li><li>每个节点都可以包含多层指针，层数是 1 到 32 之间的随机数</li><li>不同层指针到下一个节点的跨度不同，层级越高，跨度越大</li><li>增删改查效率与红黑树基本一致，实现却更简单</li></ul><br><p><strong>String</strong>：Redis 中最常见的数据存储类型</p><ul><li>基本编码为 OBJ_ENCODING_RAW，基于 SDS 实现，存储上限为 512 MB</li><li>如果存储 SDS 长度小于 44 字节则可以采用 OBJ_ENCODING_EMBSTR 编码，此时 object head 和 SDS 是一段连续的空间，效率更高。</li><li>如果存储的字符串是整数值，并且在 LONG_MAX 范围内，则会采用 OBJ_ENCODING_INT 编码，将字符串转换为 Long 类型后直接将数据保存在 RedisObject 的 ptr 指针位置，刚好为 8 字节。</li></ul><br><p><strong>List</strong>：Redis 的 List 结构类似一个双端链表，可以从首尾操作列表</p><ul><li>在 3.2 版本之前，Redis 采用 ZipList 和 LinkedList 来实现 List</li><li>在 3.2 版本之后，Redis 统一采用 QuickList 来实现 List</li></ul><br><p><strong>Set</strong>：Redis 中的集合，不一定确保元素有序，可以满足元素唯一、查询效率要求极高。</p><ul><li>为了查询效率和唯一性，Set 采用了 OBJ_ENCODING_HT 编码。Dict 的 Key 保存元素，Value 为 null</li><li>当存储所有的数据都是整数，并且元素不超过 512，采用 OBJ_ENCODING_INSET 编码节省内存</li></ul><br><p><strong>ZSet</strong>：Redis 中的 ZSet，可以满足键值存储、键必须唯一、可排序</p><ul><li>键值存储、键必须唯一可以采用 OBJ_ENCODING_HT 编码；可以排序，并且可以同时存储 score 和 element 采用 OBJ_ENCODING_SKIPLIST 实现。</li><li>当元素不多时，ZSet 采用 OBJ_ENCODING_ZIPLIST 节省内存；但由于 ZipList 没有排序功能，所以需要 ZSet 编码实现 <ul><li>score 和 element 是紧挨着的 entry ，element 在前，score 在后</li><li>按照 score 生序排列；score 越小越接近对首，score 越大越接近队尾</li></ul></li></ul><br><p><strong>Hash</strong>：Redis 中的 Hash 都是键值存储，并且键唯一，可以通过键获取值。</p><ul><li>Hash 结构默认采用 ZipList 编码，用以节省内存。 ZipList 中相邻的两个 Entry 分别保存 Field 和 Value</li><li>当数据量较大时，Hash 结构会转为 OBJ_ENCODING_HT。因为 ZipList 底层是连续的内存空间，这种结构节约内存，但不适合做修改，容易引发内存拷贝。</li></ul></div><h2 id="数据结构" tabindex="-1">数据结构 <a class="header-anchor" href="#数据结构" aria-label="Permalink to &quot;数据结构&quot;">​</a></h2><h3 id="sds" tabindex="-1">SDS <a class="header-anchor" href="#sds" aria-label="Permalink to &quot;SDS&quot;">​</a></h3><p>我们都知道 Redis 中保存的 Key 是字符串，Value 往往是字符串或者字符串的集合。可见字符串是 Redis 中最常用的一种数据结构。</p><br><p>不过 Redis 没有直接使用 C 语言中的字符串，因为 C 语言字符串存在很多问题：</p><ul><li><p>获取字符串长度的需要通过运算，时间复杂度 O(n)</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// c语言，声明字符串</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">char*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;hello&quot;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 本质是字符数组，并且带上结束标识 {&#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;, &#39;\\0&#39;}</span></span></code></pre></div></li><li><p>非二进制安全：通过结束标识读取数据，所以在字符中不能包含特殊字符。</p></li><li><p>不可修改</p></li></ul><br><p>Redis 构建了一种新的字符串结构，称为简单动态字符串（<strong>S</strong>imple <strong>D</strong>ynamic <strong>S</strong>tring），简称SDS。</p><p>例如，我们执行命令：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">127.0.0.1:6379&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> set name 慕斯</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">OK</span></span></code></pre></div><p>那么 Redis 将在底层创建两个 SDS，其中一个是包含 “name” 的 SDS，另一个是包含 “慕斯” 的 SDS。</p><br><p>Redis 是 C 语言实现的，其中 SDS 是一个结构体，源码如下：</p><p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-20240315143634713.png" alt="image-20240315143634713" loading="lazy"></p><br><p>例如，一个包含字符串 <code>name</code> 的 SDS 结构如下：</p><p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-20240315161319498.png" alt="image-20240315161319498" loading="lazy"></p><br><p>SDS 之所以叫做动态字符串，是因为它具备动态扩容的能力，例如一个内容为 <code>hi</code> 的 SDS：</p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-20240315161347086.png" alt="image-20240315161347086" style="zoom:50%;"><br><p>假如我们要给 SDS 追加一段字符串 <code>,Amy</code>，这里首先会申请新内存空间：</p><ul><li>如果新字符串小于 1M，则新空间为扩展后字符串长度的两倍 +1；</li><li>如果新字符串大于 1M，则新空间为扩展后字符串长度 +1M+1。称为<strong>内存预分配</strong>。 <ul><li>注意：+1 是要带上的结束标识。</li></ul></li></ul><p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-20240315161435077.png" alt="image-20240315161435077" loading="lazy"></p><br><div class="tip custom-block"><p class="custom-block-title">📌 SDS 数据的优点</p><ul><li>获取字符串长度的时间复杂度为 O(1)</li><li>支持动态扩容，减少分配内存次数</li><li>二进制安全，可以存放特殊标识。<strong>因为是按照长度读取数据，而不是按照结束标识读取数据。</strong></li></ul></div><br><h3 id="intset" tabindex="-1">IntSet <a class="header-anchor" href="#intset" aria-label="Permalink to &quot;IntSet&quot;">​</a></h3><p>IntSet 是 Redis 中 Set 集合的一种实现方式，基于整数数组来实现，并且具备长度可变、有序等特征。</p><p><strong>结构如下</strong></p><p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-20240315144039690.png" alt="image-20240315144039690" loading="lazy"></p><br><p>其中的 encoding 包含三种模式，表示存储的整数大小不同：</p><p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-20240315144054030.png" alt="image-20240315144054030" loading="lazy"></p><br><p>为了方便查找，Redis 会将 intset 中所有的整数<strong>按照升序</strong>依次保存在 contents 数组中，结构如图：</p><p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-20240315161449022.png" alt="image-20240315161449022" loading="lazy"></p><p>现在，数组中每个数字都在 <code>int16_t</code> 的范围内，因此采用的编码方式是 <code>INTSET_ENC_INT16</code>，每部分占用的字节大小为：</p><ul><li>encoding：4字节</li><li>length：4字节</li><li>contents：2字节 * 3 = 6字节</li></ul><blockquote><p>💡思考：为什么 contents 都采用相同的字节存储数据。<strong>方便根据角标查询数据。</strong></p></blockquote><br><h4 id="intset升级" tabindex="-1">IntSet升级 <a class="header-anchor" href="#intset升级" aria-label="Permalink to &quot;IntSet升级&quot;">​</a></h4><p>现在，假设有一个 intset，元素为 [5，10，20]，采用的编码是 INTSET_ENC_INT16，则每个整数占 2 字节：</p><p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-20240315161504954.png" alt="image-20240315161504954" loading="lazy"></p>`,47),o=i("br",null,null,-1),d=i("p",null,"以当前案例来说流程如下：",-1),k=i("li",null,[i("p",null,[i("strong",null,"倒序"),s("依次将数组中的元素拷贝到扩容后的正确位置")])],-1),u=n('<p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-20240315161517606.png" alt="image-20240315161517606" loading="lazy"></p><ul><li>将待添加的元素放入数组末尾</li></ul><p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-20240315161529373.png" alt="image-20240315161529373" loading="lazy"></p><ul><li>最后，将 inset 的 encoding 属性改为INTSET_ENC_INT32，将 length 属性改为 4</li></ul><p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-20240315161540277.png" alt="image-20240315161540277" loading="lazy"><br></p><blockquote><p>💡 思考：为什么要倒序一次将数组中的元素拷贝到正确位置。</p><p>因为正序扩容会将后面的数据覆盖，而倒序则不会覆盖数据。</p></blockquote><br><h4 id="insert新增流程" tabindex="-1">Insert新增流程 <a class="header-anchor" href="#insert新增流程" aria-label="Permalink to &quot;Insert新增流程&quot;">​</a></h4><p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-20240315144530223.png" alt="image-20240315144530223" loading="lazy"></p><br><h4 id="insert升级流程" tabindex="-1">Insert升级流程 <a class="header-anchor" href="#insert升级流程" aria-label="Permalink to &quot;Insert升级流程&quot;">​</a></h4><p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-20240315144538221.png" alt="image-20240315144538221" loading="lazy"></p><br><div class="warning custom-block"><p class="custom-block-title">💡总结：Intset 可以看做是特殊的整数数组，具备一些特点</p><ul><li>Redis 会确保 Intset 中的元素唯一、有序</li><li>具备类型升级机制，可以节省内存空间</li><li>底层采用二分查找方式来查询</li></ul></div><br><h3 id="dict" tabindex="-1">Dict <a class="header-anchor" href="#dict" aria-label="Permalink to &quot;Dict&quot;">​</a></h3><p>我们知道Redis是一个键值型（Key-Value Pair）的数据库，我们可以根据键实现快速的增删改查。而键与值的映射关系正是通过Dict来实现的。</p><p>Dict由三部分组成，分别是：哈希表（DictHashTable）、哈希节点（DictEntry）、字典（Dict）</p><p><strong>DictHashTable</strong>、<strong>DictEntry</strong></p><p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-20240315144804052.png" alt="image-20240315144804052" loading="lazy"></p><p>注意：union 结构是一个泛型，4个数据只能满足一个。</p><br><p>当我们向 Dict 添加键值对时，Redis 首先根据 key 计算出 hash 值（h），然后利用 h &amp; sizemask 来计算元素应该存储到数组中的哪个索引位置。我们存储 k1 = v1 ，假设 k1 的哈希值 h = 1，则 1 &amp; 3 = 1，因此k1 = v1要存储到数组角标1位置。</p><blockquote><p>注意：2^n -1 可以使用与运算 &amp; 代替取模 % 运算，效率更高</p></blockquote><br><p>k1 和 k2 哈希冲突的情况，直接往队首添加更方便，不需要遍历链表</p><p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-20240315161711074.png" alt="image-20240315161711074" loading="lazy"></p><br><p><strong>Dict</strong></p><p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-20240315145257633.png" alt="image-20240315145257633" loading="lazy"></p><br><p><strong>结构展示</strong></p><p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-20240315161727721.png" alt="image-20240315161727721" loading="lazy"></p><br><h4 id="dict的扩容" tabindex="-1">Dict的扩容 <a class="header-anchor" href="#dict的扩容" aria-label="Permalink to &quot;Dict的扩容&quot;">​</a></h4><p>Dict 中的 HashTable 就是数组结合单向链表的实现，当集合中元素较多时，必然导致哈希冲突增多，链表过长，则查询效率会大大降低。</p><p>Dict 在每次新增键值对时都会检查<strong>负载因子</strong>（LoadFactor = used / size） ，满足以下两种情况时会触发<strong>哈希表扩容</strong>：</p><ul><li>哈希表的 LoadFactor &gt;= 1，并且服务器没有执行 <code>BGSAVE</code> 或者 <code>BGREWRITEAOF</code> 等后台进程；</li><li>哈希表的 LoadFactor &gt; 5 ；</li></ul><p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-20240315145359792.png" alt="image-20240315145359792" loading="lazy"></p><br><h4 id="dict的收缩" tabindex="-1">Dict的收缩 <a class="header-anchor" href="#dict的收缩" aria-label="Permalink to &quot;Dict的收缩&quot;">​</a></h4><p>Dict除了扩容以外，每次删除元素时，也会对负载因子做检查，当LoadFactor &lt; 0.1 时，会做哈希表收缩：</p><p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-20240315145411909.png" alt="image-20240315145411909" loading="lazy"></p><br><h4 id="dict的rehash" tabindex="-1">Dict的rehash <a class="header-anchor" href="#dict的rehash" aria-label="Permalink to &quot;Dict的rehash&quot;">​</a></h4><p>不管是扩容还是收缩，必定会创建新的哈希表，导致哈希表的 size 和 sizemask 变化，而 key 的查询与sizemask 有关。因此必须对哈希表中的每一个 key 重新计算索引，插入新的哈希表，这个过程称为rehash。过程是这样的：</p><ol><li><p>计算新 hash表的 realeSize，值取决于当前要做的是扩容还是收缩：</p><ul><li>如果是扩容，则新 size 为第一个大于等于 dict.ht[0].used + 1 的 2^n^</li></ul><ul><li>如果是收缩，则新 size 为第一个大于等于 dict.ht[0].used 的 2^n^ （不得小于4）</li></ul></li><li><p>按照新的 realeSize 申请内存空间，创建 dictht，并赋值给 dict.ht[1]</p></li><li><p>设置 dict.rehashidx = 0，标示开始 rehash</p></li><li><p>将 dict.ht[0] 中的每一个dictEntry 都 rehash 到 dict.ht[1]</p></li><li><p>将 dict.ht[1] 赋值给 dict.ht[0]，给 dict.ht[1] 初始化为空哈希表，释放原来的 dict.ht[0] 的内存</p></li><li><p>将 rehashidx 赋值为 -1，代表 rehash 结束</p></li></ol><br><p><strong>流程示意图</strong></p><p>需要扩容的数据 k5，v5</p><p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-20240322161254317.png" alt="image-20240322161254317" loading="lazy"></p><br><p>重新计算 hash 表的 realeSize，扩容为 8，按照新的 realeSize 申请内存空间，创建 dictht，并赋值给 dict.ht[1]</p><p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-20240322162042571.png" alt="image-20240322162042571" loading="lazy"></p><br><p>设置 dict.rehashidx = 0，标示开始 rehash，将 dict.ht[0] 中的每一个 dictEntry 都 rehash 到 dict.ht[1]</p><p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-20240322162151796.png" alt="image-20240322162151796" loading="lazy"></p><br><p>将 dict.ht[1] 赋值给 dict.ht[0]，给 dict.ht[1] 初始化为空哈希表，释放原来的 dict.ht[0] 的内存，将 rehashidx 赋值为 -1，代表 rehash 结束</p><p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-20240322162456812.png" alt="image-20240322162456812" loading="lazy"></p><br><p><strong>特别注意</strong></p>',62),m=i("p",null,"1.计算新 hash 表的 realeSize，值取决于当前要做的是扩容还是收缩：",-1),y=i("ul",null,[i("li",null,"如果是扩容，则新 size 为第一个大于等于 dict.ht[0].used + 1 的2^n^")],-1),b=i("ul",null,[i("li",null,"如果是收缩，则新 size 为第一个大于等于 dict.ht[0].used 的 2^n^（不得小于4）")],-1),F=i("p",null,"2.按照新的 realeSize 申请内存空间，创建 dictht，并赋值给 dict.ht[1]",-1),E=i("p",null,"3.设置 dict.rehashidx = 0，标示开始 rehash",-1),z=i("p",null,[i("s",null,"4.将 dict.ht[0] 中的每一个dictEntry 都 rehash 到 dict.ht[1]")],-1),S=n(`<p>5.将 dict.ht[1] 赋值给 dict.ht[0]，给 dict.ht[1] 初始化为空哈希表，释放原来的 dict.ht[0] 的内存</p><p>6.将 rehashidx 赋值为 -1，代表 rehash 结束</p><p>7.在 rehash 过程中，新增操作，则直接写入 ht[1]，查询、修改和删除则会在 dict.ht[0] 和 dict.ht[1] 依次查找并执行。这样可以确保 ht[0] 的数据只减不增，随着 rehash 最终为空</p><br><div class="warning custom-block"><p class="custom-block-title">💡 总结：Dict的结构</p><ul><li>类似 Java 的 HashTable，底层是数组加链表来解决哈希冲突</li><li>Dict 包含两个哈希表，ht[0] 平常用，ht[1] 用来rehash</li></ul><p><strong>Dict 的伸缩</strong></p><ul><li><p>判断第一个哈希表 （dict.ht[0]） 的负载因子（LoadFactor = used / size）是否大于等于 1 并且没有后台进程，或负载因子大于 5，则扩容；若负载因子小于 0.1 则缩容。</p></li><li><p>如果扩容，则新 size 为第一个大于等于 used + 1 的 2^n^；如果缩容，则新 size 为小于等于 used 的 2^n^(最小为4)。并按照新的 size 申请内存空间，创建 dictht，并赋值给 dict.ht[1]</p><ul><li>举例：如果原先 size 为 4，used 为 5，则新 size 扩容为 8；如果原先 size 为 10，used 为 1，则新 size 缩容为 4；</li></ul></li><li><p>设置 dict.rehashidx = 0，标记开始 rehash。将 dict.ht[0] 中的每一个 dictEntry 都 rehash 到 dict.ht[1]。</p></li><li><p>将 dict.ht[1] 赋值给 dict.ht[0]，给 dict.ht[1] 初始化为空哈希表，并将 rehashidx 赋值为 -1，代表 rehash 结束。</p><ul><li>rehash 是一个渐进式的 rehash。因为如果 Dict 包含数据量过多的 entry，要在一次 rehash 完成则极有可能造成主线程阻塞；所以 Dict 的 rehash 是分多次、渐进式完成。</li><li>rehash 过程中的新增操作直接写入 ht[1]，查询、修改和删除则会在 ht[0] 和 ht[1] 依次查找并执行。保证 ht[0] 只减不增，随着 rehash 最终结束。</li></ul></li></ul></div><br><h3 id="ziplist" tabindex="-1">ZipList <a class="header-anchor" href="#ziplist" aria-label="Permalink to &quot;ZipList&quot;">​</a></h3><p>ZipList 是一种特殊的“双端链表” ，由一系列特殊编码的<strong>连续内存块</strong>组成。可以在任意一端进行压入/弹出操作, 并且该操作的时间复杂度为 O(1)。</p><p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-20240315161810757.png" alt="image-20240315161810757" loading="lazy"></p><br><p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-20240315145653044.png" alt="image-20240315145653044" loading="lazy"></p><p><strong>用途</strong></p><p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-169355136195436.png" alt="image-169355136195436" loading="lazy"></p><br><h4 id="ziplistentry" tabindex="-1">ZipListEntry <a class="header-anchor" href="#ziplistentry" aria-label="Permalink to &quot;ZipListEntry&quot;">​</a></h4><p>ZipList 中的 Entry 并不像普通链表那样记录前后节点的指针，<mark>因为记录两个指针要占用16个字节，浪费内存</mark>。而是采用了下面的结构：</p><p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-20240315145719866.png" alt="image-20240315145719866" loading="lazy"></p><ul><li>previous_entry_length：前一节点的长度，占 1 个或 5 个字节。 <ul><li>如果前一节点的长度小于 254 字节，则采用 1 个字节来保存这个长度值</li><li>如果前一节点的长度大于 254 字节，则采用 5 个字节来保存这个长度值，第一个字节为 0xfe，后四个字节才是真实长度数据</li></ul></li><li>encoding：编码属性，记录 conten t的数据类型（字符串还是整数）以及长度，占用1个、2个或5个字节</li><li>contents：负责保存节点的数据，可以是字符串或整数</li></ul><br><div class="warning custom-block"><p class="custom-block-title">注意：ZipList 中所有存储长度的数值均采用小端字节序，即低位字节在前，高位字节在后。</p><ul><li>例如：数值0x1234，采用小端字节序后实际存储值为：0x3412</li></ul></div><br><h4 id="encoding编码" tabindex="-1">Encoding编码 <a class="header-anchor" href="#encoding编码" aria-label="Permalink to &quot;Encoding编码&quot;">​</a></h4><p>ZipListEntry 中的 encoding 编码分为字符串和整数两种：</p><p>字符串：如果 encoding 是以“00”、“01”或者“10”开头，则证明 content 是字符串</p><p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-20240315145925835.png" alt="image-20240315145925835" loading="lazy"></p><br><p>例如，我们要保存字符串：“ab”和 “bc”</p><p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-20240325093439335.png" alt="image-20240325093439335" loading="lazy"></p><p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-20240315145808955.png" alt="image-20240315145808955" loading="lazy"></p><p>ZipListEntry 中的 encoding 编码分为字符串和整数两种：</p><ul><li>整数：如果 encoding 是以“11”开始，则证明 content 是整数，且 encoding 固定只占用1个字节</li></ul><p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-20240315150009641.png" alt="image-20240315150009641" loading="lazy"></p><br><p>例如，一个 ZipList 中包含两个整数值：“2”和“5”</p><p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-20240315145955973.png" alt="image-20240315145955973" loading="lazy"></p><p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-20240315150021007.png" alt="image-20240315150021007" loading="lazy"></p><br><h4 id="连锁更新问题" tabindex="-1">连锁更新问题 <a class="header-anchor" href="#连锁更新问题" aria-label="Permalink to &quot;连锁更新问题&quot;">​</a></h4><p>ZipList 的每个 Entry 都包含 previous_entry_length 来记录上一个节点的大小，长度是 1 个或 5 个字节：</p><ul><li>如果前一节点的长度小于 254 字节，则采用 1 个字节来保存这个长度值</li><li>如果前一节点的长度大于等于 254 字节，则采用 5 个字节来保存这个长度值，第一个字节为 0xfe，后四个字节才是真实长度数据</li></ul><p>现在，假设我们有N个连续的、长度为 250~253 字节之间的 entry，因此 entry 的 previous_entry_length 属性用 1 个字节即可表示。</p><br><p><strong>如图所示</strong></p><p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-20240325095912433.png" alt="image-20240325095912433" loading="lazy"></p><p>在队首新增一个 254 bytes 数据</p><p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-20240315150051486.png" alt="image-20240315150051486" loading="lazy"></p><p>ZipList 这种特殊情况下产生的连续多次空间扩展操作称之为连锁更新（Cascade Update）。新增、删除都可能导致连锁更新的发生。</p><br><div class="warning custom-block"><p class="custom-block-title">💡 总结：ZipList特性</p><ul><li>压缩列表的可以看做一种连续内存空间的&quot;双向链表&quot;</li><li>列表的节点之间不是通过指针连接，而是记录上一节点和本节点长度来寻址，内存占用较低</li><li>如果列表数据过多，导致链表过长，可能影响查询性能</li><li>增或删较大数据时有可能发生连续更新问题，ListPack 解决了连续更新问题</li></ul></div><br><h3 id="quicklist" tabindex="-1">QuickList <a class="header-anchor" href="#quicklist" aria-label="Permalink to &quot;QuickList&quot;">​</a></h3><p>问题1：ZipList 虽然节省内存，但申请内存必须是连续空间，如果内存占用较多，申请内存效率很低。怎么办？</p><p>​ 答：为了缓解这个问题，我们必须限制 ZipList 的长度和 entry 大小。</p><p>问题2：但是我们要存储大量数据，超出了 ZipList 最佳的上限该怎么办？</p><p>​ 答：我们可以创建多个 ZipList 来分片存储数据。</p><p>问题3：数据拆分后比较分散，不方便管理和查找，这多个 ZipList 如何建立联系？</p><p>​ 答：Redis 在 3.2 版本引入了新的数据结构 QuickList，它是一个双端链表，只不过链表中的每个节点都是一个 ZipList。</p><p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-20240315150119317.png" alt="image-20240315150119317" loading="lazy"></p><br><p>为了避免QuickList中的每个 ZipList 中 entry 过多，Redis 提供了一个配置项：<code>list-max-ziplist-size</code> 来限制。</p><p>如果值为正，则代表 ZipList 的允许的 entry 个数的最大值。如果值为负，则代表 ZipList 的最大内存大小，分 5 种情况：</p><ul><li>-1：每个ZipList的内存占用不能超过4kb</li><li>-2：每个ZipList的内存占用不能超过8kb</li><li>-3：每个ZipList的内存占用不能超过16kb</li><li>-4：每个ZipList的内存占用不能超过32kb</li><li>-5：每个ZipList的内存占用不能超过64kb</li></ul><br><p>其默认值为 -2</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">127.0.0.1:6379&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> config get list-max-ziplist-size</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;list-max-ziplist-size&quot;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;-2&quot;</span></span></code></pre></div><br><p>除了控制 ZipList 的大小，QuickList 还可以对节点的 ZipList 做压缩。通过配置项 <code>list-compress-depth </code>来控制。因为链表一般都是从首尾访问较多，所以首尾是不压缩的。这个参数是控制首尾不压缩的节点个数：</p><ul><li>0：特殊值，代表不压缩</li><li>1：标示 QuickList 的首尾各有 1 个节点不压缩，中间节点压缩</li><li>2：标示 QuickList 的首尾各有 2 个节点不压缩，中间节点压缩以此类推</li></ul><br><p>默认值</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">127.0.0.1:6379&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> config get list-compress-depth</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;list-compress-depth&quot;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;0&quot;</span></span></code></pre></div><br><p>以下是QuickList的和QuickListNode的结构源码：</p><p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-20240315151008380.png" alt="image-20240315151008380" loading="lazy"></p><br><p>我们接下来用一段流程图来描述当前的这个结构</p><p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-20240315151018603.png" alt="image-20240315151018603" loading="lazy"></p><br><div class="warning custom-block"><p class="custom-block-title">总结：QuickList 的特点</p><ul><li>是一个节点为 ZipList 的双端链表</li><li>节点采用 ZipList，解决了传统链表的内存占用问题</li><li>控制了 ZipList 大小，解决连续内存空间申请效率问题</li><li>中间节点可以压缩，进一步节省了内存</li></ul></div><br><h3 id="skiplist" tabindex="-1">SkipList <a class="header-anchor" href="#skiplist" aria-label="Permalink to &quot;SkipList&quot;">​</a></h3><p>SkipList（跳表）首先是链表，但与传统链表相比有几点差异：</p><ul><li>元素按照升序排列存储</li><li>节点可能包含多个指针，指针跨度不同。</li></ul><p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-20240315151034097.png" alt="image-20240315151034097" loading="lazy"></p><br><p><strong>源码展示</strong></p><p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-20240315151119583.png" alt="image-20240315151119583" loading="lazy"></p><br><p><strong>流程一</strong></p><p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-20240315151129803.png" alt="image-20240315151129803" loading="lazy"></p><br><p><strong>流程二</strong></p><p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-20240315151137883.png" alt="image-20240315151137883" loading="lazy"></p><br><p><strong>流程三</strong></p><p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-20240315151150609.png" alt="image-20240315151150609" loading="lazy"></p><br><p><strong>流程四</strong></p><p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-20240315151206877.png" alt="image-20240315151206877" loading="lazy"></p><br><div class="warning custom-block"><p class="custom-block-title">💡总结：SkipList 的特点</p><ul><li>跳跃表是一个双向链表，每个节点都包含 score 和 ele 值</li><li>节点按照 score 值排序，score 值一样则按照 ele 字典排序</li><li>每个节点都可以包含多层指针，层数是 1 到 32 之间的随机数</li><li>不同层指针到下一个节点的跨度不同，层级越高，跨度越大</li><li>增删改查效率与红黑树基本一致，实现却更简单</li></ul></div><br><h3 id="redisobject" tabindex="-1">RedisObject <a class="header-anchor" href="#redisobject" aria-label="Permalink to &quot;RedisObject&quot;">​</a></h3><p>Redis 中的任意数据类型的键和值都会被封装为一个 RedisObject，也叫做 Redis 对象，源码如下：</p><p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-20240315151347625.png" alt="image-20240315151347625" loading="lazy"></p><p>指针在 32 位计算机中占 4 个字节，因为指针的本身的值就是内存地址，只有 4 字节才能完整的表示 32 位的内存地址。但是由于 32 位计算机内存最大空间为 2^32^ = 4 GB，有时并不满足内存的使用。所以出现了在64 位计算机，需要 8 个字节才能完整表示 64 位的内存地址。但是 2^64^，这是个很大的值，而物理内存达不到这么大，CPU要实现 64 位的寻址能力只会增加系统复杂度和地址转换成本，因此 Windows 和 Linux 都做了限制，仅仅使用虚拟地址的 48 位，2^48^ = 256 TB。但是指针的占用内存字节数还是8 （只是 Windows 和 Linux 下，低48位有效而已）.</p><br><blockquote><p>思考：什么是 RedisObject ?</p></blockquote><p>从 Redis 的使用者的角度来看，⼀个 Redis 节点包含多个 database（非 cluster 模式下默认是16个，cluster 模式下只能是1个），而一个 Database 维护了从 Key Space 到 Object Space 的映射关系。这个映射关系的 Key 是 String 类型，⽽ Value 可以是多种数据类型，</p><p>比如：String、List、Hash、Set、Sorted Set 等。我们可以看到，Key 的类型固定是 String，而 Value 可能的类型是多个。</p><p>⽽从 Redis 内部实现的⾓度来看，Database 内的这个映射关系是用⼀个 Dict 来维护的。Dict 的 Key 固定用⼀种数据结构来表达就够了，这就是动态字符串 SDS。而 Value 则比较复杂，为了在同⼀个 Dict 内能够存储不同类型的 Value，这就需要⼀个通⽤的数据结构，这个通用的数据结构就是 robj，全名是 RedisObject。</p><br><h4 id="redis的编码方式" tabindex="-1">Redis的编码方式 <a class="header-anchor" href="#redis的编码方式" aria-label="Permalink to &quot;Redis的编码方式&quot;">​</a></h4><p>Redis中会根据存储的数据类型不同，选择不同的编码方式，共包含11种不同类型：</p><p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-169355136195443.png" alt="image-169355136195443" loading="lazy"></p><br><h4 id="五种数据结构" tabindex="-1">五种数据结构 <a class="header-anchor" href="#五种数据结构" aria-label="Permalink to &quot;五种数据结构&quot;">​</a></h4><p>Redis中会根据存储的数据类型不同，选择不同的编码方式。每种数据类型的使用的编码方式如下：</p><p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-169355136195444.png" alt="image-169355136195444" loading="lazy"></p><br><h3 id="五种数据结构-1" tabindex="-1">五种数据结构 <a class="header-anchor" href="#五种数据结构-1" aria-label="Permalink to &quot;五种数据结构&quot;">​</a></h3><h4 id="string" tabindex="-1">String <a class="header-anchor" href="#string" aria-label="Permalink to &quot;String&quot;">​</a></h4><p>String 是 Redis 中最常见的数据存储类型：</p><ul><li>其基本编码方式是 RAW，基于简单动态字符串（SDS）实现，存储上限为 512MB。</li><li>如果存储的 SDS 长度小于 44 字节，则会采用 EMBSTR 编码，此时 object head 与 SDS 是一段连续空间。<mark>申请内存时只需要调用一次内存分配函数，效率更高。</mark></li><li>如果存储的字符串是整数值，并且大小在 LONG_MAX 范围内，则会采用 INT 编码：直接将数据保存在 RedisObject 的 ptr 指针位置（刚好 8 字节），不再需要SDS了。</li></ul><p><strong>底层实现⽅式</strong>：动态字符串 SDS 或者 Long</p><br><div class="warning custom-block"><p class="custom-block-title">💡思考：为什么 SDS 的长度小于 44 字节，而不采用其他字节。</p><p>RedisObject 的头占用 16 字节，SDS 数据为 44 字节，SDS 长度和申请的总字节数各占一个字节，SDS 头类型用一个字节标识，最后一个符号位用一个字节，合起来刚好位 64，为2^8^。刚好为一个内存大小，分配时不会产生内存碎片。</p></div><br><p>String 的内部存储结构⼀般是 SDS（<strong>S</strong>imple Dynamic <strong>S</strong>tring，可以动态扩展内存），但是如果⼀个 String类型的 Value 的值是数字，那么 Redis 内部会把它转成 Long 类型来存储，从⽽减少内存的使用。</p><p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-20240315152525889.png" alt="image-20240315152525889" loading="lazy"></p><br><p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-20240315152513788.png" alt="image-20240315152513788" loading="lazy"></p><br><p>确切地说，String 在 Redis 中是⽤⼀个 robj 来表示的。</p><p>用来表示 String 的 robj 可能编码成3种内部表⽰：</p><ul><li>OBJ_ENCODING_RAW</li><li>OBJ_ENCODING_EMBSTR</li><li>OBJ_ENCODING_INT</li></ul><p>其中前两种编码使⽤的是 SDS 来存储，最后⼀种 OBJ_ENCODING_INT 编码直接把 String 存成了Long 型。</p><br><div class="tip custom-block"><p class="custom-block-title">💡String 进行自增操作的原理</p><p>在对 String 进行 incr, decr 等操作的时候，如果它内部是 OBJ_ENCODING_INT 编码，那么可以直接行加减操作；如果它内部是 OBJ_ENCODING_RAW 或 OBJ_ENCODING_EMBSTR 编码，那么Redis 会先试图把 SDS 存储的字符串转成 Long 型，如果能转成功，再进行加减操作。对⼀个内部表示成 Long 型的 String 执行 append, setbit, getrange 这些命令，针对的仍然是 String 的值（即⼗进制表示的字符串），而不是针对内部表⽰的 Long 型进⾏操作。比如字符串 ”32” ，如果按照字符数组来解释，它包含两个字符，它们的 ASCII 码分别是 0x33 和 0x32 。当我们执行命令 <code>setbit key 7 0</code> 的时候，相当于把字符 0x33 变成了0x32，这样字符串的值就变成了”22”。⽽如果将字符串”32”按照内部的 64 位 Long 型来解释，那么它是 0x0000000000000020，在这个基础上执⾏ setbit 位操作，结果就完全不对了。因此，在这些命令的实现中，会把 Long 型先转成字符串再进行相应的操作。</p></div><br><h4 id="list" tabindex="-1">List <a class="header-anchor" href="#list" aria-label="Permalink to &quot;List&quot;">​</a></h4><p>Redis 的 List 类型可以从首、尾操作列表中的元素：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">127.0.0.1:6379&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> LPUSH l1 e3 e2 e1 # 从 head 写入</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">integer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) 3</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">127.0.0.1:6379&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> RPUSH l1 e4 e5 e6 # 从 tail 写入</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">integer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) 6</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">127.0.0.1:6379&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> LRANGE l1 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 6</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">	# 范围获取</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;e1&quot;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;e2&quot;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;e3&quot;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;e4&quot;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;e5&quot;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">6</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;e6&quot;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">127.0.0.1:6379&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> LPOP l1 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  # 从 head 取</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;e1&quot;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">127.0.0.1:6379&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> RPOP l1 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  # 从 tail 取</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;e6&quot;</span></span></code></pre></div><p>哪一个数据结构能满足上述特征？</p><ul><li>LinkedList ：普通链表，可以从双端访问，内存占用较高，内存碎片较多</li><li>ZipList ：压缩列表，可以从双端访问，内存占用低，存储上限低</li><li>QuickList：LinkedList + ZipList，可以从双端访问，内存占用较低，包含多个 ZipList，存储上限高</li></ul><br><p>Redis 的 List 结构类似一个双端链表，可以从首、尾操作列表中的元素：</p><ul><li><p>在 3.2 版本之前，Redis 采用 ZipList 和 LinkedList 来实现 List，当元素数量小于 512 并且元素大小小于 64 字节时采用 ZipList 编码，超过则采用 LinkedList 编码。</p></li><li><p>在 3.2 版本之后，Redis 统一采用 QuickList 来实现 List</p></li></ul><br><p><strong>源码展示</strong></p><p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-20240315153403755.png" alt="image-20240315153403755" loading="lazy"></p><br><p><strong>数据结构</strong></p><p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-20240315153358601.png" alt="image-20240315153358601" loading="lazy"></p><br><h4 id="set" tabindex="-1">Set <a class="header-anchor" href="#set" aria-label="Permalink to &quot;Set&quot;">​</a></h4><p>Set 是 Redis 中的单列集合，满足下列特点：</p><ul><li>不保证有序性</li><li>保证元素唯一</li><li>求交集、并集、差集</li></ul><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">127.0.0.1:6379&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> SADD s1 m1 m2 m3</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">integer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) 3</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">127.0.0.1:6379&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> SADD s2 m2 m3 m4</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">integer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) 3</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">127.0.0.1:6379&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> SISMEMBER S1 m1  # 判断元素是否存在</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">integer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) 0</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">127.0.0.1:6379&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> SINTER s1 s2     # 求交集</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;m2&quot;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;m3&quot;</span></span></code></pre></div><p>可以看出，Set 对查询元素的效率要求非常高，思考一下，什么样的数据结构可以满足？</p><ul><li>HashTable，也就是 Redis 中的 Dict，不过 Dict 是双列集合（可以存键、值对）</li></ul><br><p>Set 是 Redis 中的集合，不一定确保元素有序，可以满足元素唯一、查询效率要求极高。</p><ul><li>为了查询效率和唯一性，Set 采用 HT 编码（Dict）。Dict 中的 Key 用来存储元素，Value 统一为 null</li><li>当存储的所有数据都是整数，并且元素数量不超过 set-max-intset-entries 时，Set 会采用 IntSet 编码，以节省内存 <ul><li>set-max-intset-entries 的默认值是 512</li></ul></li></ul><br><p><strong>源码展示</strong></p><p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-20240315155258069.png" alt="image-20240315155258069" loading="lazy"></p><br><p><strong>结构如下</strong></p><p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-20240325142215776.png" alt="image-20240325142215776" loading="lazy"></p><p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-20240325142258890.png" alt="image-20240325142258890" loading="lazy"></p><br><h4 id="zset" tabindex="-1">ZSet <a class="header-anchor" href="#zset" aria-label="Permalink to &quot;ZSet&quot;">​</a></h4><p>ZSet 也就是 SortedSet，其中每一个元素都需要指定一个 Score 值和 Member 值：</p><ul><li>可以根据 Score 值排序后</li><li>Member 必须唯一</li><li>可以根据 Member 查询分数</li></ul><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">127.0.0.1:6379&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ZADD z1 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> m1 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">20</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> m2 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">30</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> m3</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">integer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) 3</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">127.0.0.1:6379&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ZSCORE z1 m1 # 根据member查询分数</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">&quot;10&quot;</span></span></code></pre></div><br><p>因此，Zset 底层数据结构必须满足<mark>键值存储、键必须唯一、可排序</mark>这几个需求。之前学习的哪种编码结构可以满足？</p><ul><li>SkipList：可以排序，并且可以同时存储 Score 和 ele值（member）</li><li>HT（Dict）：可以键值存储，并且可以根据 Key 找 Value</li></ul><br><p><strong>源码展示</strong></p><p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-20240315155639854.png" alt="image-20240315155639854" loading="lazy"></p><br><p><strong>数据结构</strong></p><p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-20240315155654680.png" alt="image-20240315155654680" loading="lazy"></p><br><p>当元素数量不多时，HT 和 SkipList 的优势不明显，而且更耗内存。因此 Zset 还会采用 ZipList 结构来节省内存，不过需要同时满足两个条件：</p><ul><li>元素数量小于 zset_max_ziplist_entries，默认值 128</li><li>每个元素都小于 zset_max_ziplist_value 字节，默认值 64</li></ul><br><p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-20240315155805345.png" alt="image-20240315155805345" loading="lazy"></p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-20240315155822660.png" alt="image-20240315155822660" style="zoom:50%;"><br><p>Ziplist 本身没有排序功能，而且没有键值对的概念，因此需要有 Zset 通过编码实现：</p><ul><li>ZipList 是连续内存，因此 Score 和 Element 是紧挨在一起的两个 Entry， Element 在前，Score 在后</li><li>Score 越小越接近队首，Score 越大越接近队尾，按照 Score 值升序排列</li></ul><p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-20240315155845189.png" alt="image-20240315155845189" loading="lazy"></p><br><h4 id="hash" tabindex="-1">Hash <a class="header-anchor" href="#hash" aria-label="Permalink to &quot;Hash&quot;">​</a></h4><p>hash结构如下</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">127.0.0.1:6379&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> HSET user:1 name Jack age </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">21</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">integer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) 2</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">127.0.0.1:6379&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> HGET user:1 name  # 根据 field 获取 value</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">&quot;Jack&quot;</span></span></code></pre></div><p>zset集合如下</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">127.0.0.1:6379&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ZADD z1 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> m1 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">20</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> m2 </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">30</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> m3</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">integer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) 3</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">127.0.0.1:6379&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ZSCORE z1 m1 # 根据member查询分数</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">&quot;10&quot;</span></span></code></pre></div><br><p>Hash 结构与 Redis 中的 Zset 非常类似：</p><ul><li>都是键值存储</li><li>都需求根据键获取值</li><li>键必须唯一</li></ul><p>区别如下：</p><ul><li>Zset 的键是 Member，值是 Score；Hash 的键和值都是任意值</li><li>Zset 要根据 Score 排序；Hash 则无需排序</li></ul><br><p>因此，Hash 底层采用的编码与 Zset 也基本一致，只需要把排序有关的 SkipList 去掉即可：</p><ul><li><p>Hash 结构默认采用 ZipList 编码，用以节省内存。 ZipList 中相邻的两个 Entry 分别保存 Field 和 Value</p></li><li><p>当数据量较大时，Hash 结构会转为HT编码，也就是 Dict，触发条件有两个：</p><ul><li>ZipList 中的元素数量超过了 hash-max-ziplist-entries（默认512）</li><li>ZipList 中的任意 Entry 大小超过了 hash-max-ziplist-value（默认64字节）</li></ul></li></ul><br><p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-20240315160556831.png" alt="image-20240315160556831" loading="lazy"></p><p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-20240315160651164.png" alt="image-20240315160651164" loading="lazy"></p><br><p>Redis 的 Hash 之所以这样设计，是因为当 Ziplist 变得很⼤的时候，它有如下几个缺点：</p><ul><li>每次插⼊或修改引发的 realloc 操作会有更⼤的概率造成内存拷贝，从而降低性能。</li><li>⼀旦发生内存拷贝，内存拷贝的成本也相应增加，因为要拷贝更⼤的⼀块数据。</li><li>当 Ziplist 数据项过多的时候，在它上⾯查找指定的数据项就会性能变得很低，因为 Ziplist 上的查找需要进行遍历。</li></ul><p>总之，Ziplist 本来就设计为各个数据项挨在⼀起组成连续的内存空间，这种结构并不擅长做修改操作。⼀旦数据发⽣改动，就会引发内存 realloc，可能导致内存拷贝。</p><br><p><strong>代码实现</strong></p><p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-20240315161019325.png" alt="image-20240315161019325" loading="lazy"></p>`,219);function C(_,B,L,D,q,v){const a=p("font");return r(),h("div",null,[g,i("p",null,[s("我们向该其中添加一个数字：50,000，这个数字超出了 int16_t 的范围，intset 会自动"),l(a,{color:"red"},{default:t(()=>[s("升级")]),_:1}),s("编码方式到合适的大小。")]),o,d,i("ul",null,[i("li",null,[i("p",null,[s("升级编码为 "),l(a,{color:"red"},{default:t(()=>[s("INTSET_ENC_INT32")]),_:1}),s(", 每个整数占 4字节，并按照新的编码方式及元素个数扩容数组")])]),k]),u,i("p",null,[s("Dict 的 rehash 并不是一次性完成的。试想一下，如果 Dict 中包含数百万的 entry，要在一次 rehash 完成，极有可能导致主线程阻塞。因此 Dict 的 rehash 是分多次、渐进式的完成，因此称为 "),l(a,{color:"red"},{default:t(()=>[s("渐进式rehash")]),_:1}),s("。流程如下：")]),m,y,b,F,E,z,l(a,{color:"red"},{default:t(()=>[s("4.每次执行新增、查询、修改、删除操作时，都检查一下 dict.rehashidx 是否大于 -1，如果是则将 dict.ht[0].table[rehashidx] 的 entry 链表 rehash 到 dict.ht[1]，并且将 rehashidx++。直至 dict.ht[0] 的所有数据都 rehash到 dict.ht[1] ")]),_:1}),S])}const w=e(c,[["render",C]]);export{R as __pageData,w as default};
