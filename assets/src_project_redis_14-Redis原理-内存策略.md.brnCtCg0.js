import{_ as i,c as l,o as s,V as a}from"./chunks/framework.syB9hai_.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"src/project/redis/14-Redis原理-内存策略.md","filePath":"src/project/redis/14-Redis原理-内存策略.md","lastUpdated":1730648753000}'),e={name:"src/project/redis/14-Redis原理-内存策略.md"},t=a(`<nav class="table-of-contents"><ul><li><a href="#redis内存策略">Redis内存策略</a><ul><li><a href="#内存回收">内存回收</a></li><li><a href="#过期策略">过期策略</a><ul><li><a href="#db结构">DB结构</a></li><li><a href="#惰性删除">惰性删除</a></li><li><a href="#周期删除">周期删除</a></li><li><a href="#总结">总结</a></li></ul></li><li><a href="#内存淘汰">内存淘汰</a></li></ul></li></ul></nav><br><p>当内存使用达到上限时，就无法存储更多数据了。为了解决这个问题，Redis 提供了一些策略实现内存回收：</p><ul><li>内存过期策略：通过 Expire 命令给 Redis 的 Key 设置 TTL <ul><li>惰性删除：每次查找 Key 时判断是否过期，如果过期则删除</li><li>定期删除：定期抽样部分 Key，判断是否过期，如果过期则删除。 <ul><li>SLOW 模式执行频率默认为10，每次不超过 25ms （<strong>高吞吐</strong>）</li><li>FAST 模式执行频率不固定，但两次间隔不低于 2ms，每次耗时不超过 1ms（<strong>低延迟</strong>）</li></ul></li><li>Redis的过期删除策略：惰性删除 + 定期删除两种策略进行配合使用。</li></ul></li><li>内存淘汰策略：主动挑选部分 Key 删除以释放更多内存的流程 <ul><li>淘汰策略 <ul><li>noeviction： 不淘汰任何key，但是内存满时不允许写入新数据，<strong>默认就是这种策略</strong>。</li><li>volatile-ttl： 对设置了TTL的key，比较key的剩余TTL值，TTL越小越先被淘汰</li><li>allkeys-random：对全体key ，随机进行淘汰。也就是直接从db-&gt;dict中随机挑选</li><li>volatile-random：对设置了TTL的key ，随机进行淘汰。也就是从db-&gt;expires中随机挑选</li><li>allkeys-lru： 对全体key，基于LRU算法进行淘汰</li><li>volatile-lru： 对设置了TTL的key，基于LRU算法进行淘汰</li><li>allkeys-lfu： 对全体key，基于LFU算法进行淘汰</li><li>volatile-lfu： 对设置了TTL的key，基于LFI算法进行淘汰</li></ul></li><li>容易混淆 <ul><li>LRU：最近使用。根据每个 Key 的最后访问时间来淘汰</li><li>LFU：使用频率。根据每个 Key 的访问频率来淘汰</li></ul></li><li>使用建议 <ul><li>如果业务有冷热数据区分，根据访问时间来淘汰，建议使用 allkeys-lru，把最近访问的数据留在缓存中。</li><li>如果业务没有冷热数据区分，访问频率差别不大，建议选择 allkeys-random，随机选择淘汰</li><li>如果有短时高频访问的数据，则可以使用 allkeys-lfu 或 allkeys-lfu</li><li>如果业务中有指定的需求，则可以使用 volaitle-lru 。置顶数据设置不过期，不会被删除，淘汰设置过期时间的数据</li></ul></li></ul></li></ul><br><h2 id="redis内存策略" tabindex="-1">Redis内存策略 <a class="header-anchor" href="#redis内存策略" aria-label="Permalink to &quot;Redis内存策略&quot;">​</a></h2><h3 id="内存回收" tabindex="-1">内存回收 <a class="header-anchor" href="#内存回收" aria-label="Permalink to &quot;内存回收&quot;">​</a></h3><p>Redis之所以性能强，最主要的原因就是基于内存存储。然而单节点的Redis其内存大小不宜过大，会影响持久化或主从同步性能。</p><p>我们可以通过修改配置文件来设置Redis的最大内存：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 格式：</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># maxmemory &lt;bytes&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 例如：</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">maxmemory</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">gb</span></span></code></pre></div><p>当内存使用达到上限时，就无法存储更多数据了。为了解决这个问题，Redis 提供了一些策略实现内存回收：</p><ul><li>内存过期策略</li><li>内存淘汰策略</li></ul><br><h3 id="过期策略" tabindex="-1">过期策略 <a class="header-anchor" href="#过期策略" aria-label="Permalink to &quot;过期策略&quot;">​</a></h3><p>在学习Redis缓存的时候我们说过，可以通过 Expire 命令给 Redis 的 Key 设置 TTL（存活时间）：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">127.0.0.1:6379&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> set name jack</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">OK</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">127.0.0.1:6379&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> expire name </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> # 设置ttl为5s</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">integer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) 1</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">127.0.0.1:6379&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> get name # 立即访问</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">&quot;jack&quot;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">127.0.0.1:6379&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> get name # </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">秒后访问</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">nil</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>可以发现，当key的TTL到期以后，再次访问name返回的是nil，说明这个key已经不存在了，对应的内存也得到释放。从而起到内存回收的目的。</p><br><blockquote><p>思考：Redis 如何知道一个 Key 是否过期呢？</p></blockquote><h4 id="db结构" tabindex="-1">DB结构 <a class="header-anchor" href="#db结构" aria-label="Permalink to &quot;DB结构&quot;">​</a></h4><p>Redis 本身是一个典型的 key-value 内存存储数据库，因此所有的 key、value 都保存在之前学习过的Dict 结构中。不过在其 database 结构体中，有两个 Dict：一个用来记录 key-value；另一个用来记录 key-TTL。</p><p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-20240315171629763.png" alt="image-20240315171629763" loading="lazy"></p><p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-20240315171644150.png" alt="image-20240315171644150" loading="lazy"></p><p>Redis 是如何知道一个 Key 是否过期呢？</p><ul><li>利用两个 Dict 分别记录 key-value 对及 key-ttl 对</li></ul><br><blockquote><p>思考：是不是 TTL 到期就立即删除了呢？</p></blockquote><h4 id="惰性删除" tabindex="-1">惰性删除 <a class="header-anchor" href="#惰性删除" aria-label="Permalink to &quot;惰性删除&quot;">​</a></h4><p>惰性删除：顾明思议并不是在 TTL 到期后就立刻删除，而是在访问一个 Key 的时候，检查该 Key 的存活时间，如果已经过期才执行删除。</p><p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-20240315171748162.png" alt="image-20240315171748162" loading="lazy"></p><br><h4 id="周期删除" tabindex="-1">周期删除 <a class="header-anchor" href="#周期删除" aria-label="Permalink to &quot;周期删除&quot;">​</a></h4><p>周期删除：顾明思议是通过一个定时任务，周期性的抽样部分过期的 Key，然后执行删除。执行周期有两种：</p><ul><li>Redis 服务初始化函数 initServer() 中设置定时任务，按照 server.hz 的频率来执行过期 Key 清理，模式为 SLOW</li><li>Redis 的每个事件循环前会调用 beforeSleep() 函数，执行过期 Key 清理，模式为 FAST</li></ul><p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-20240315171943867.png" alt="image-20240315171943867" loading="lazy"></p><br><p>SLOW 模式规则：</p><ul><li><p>执行频率受 server.hz 影响，默认为 10，即每秒执行 10 次，每个执行周期 100ms</p></li><li><p>执行清理耗时不超过一次执行周期的 25% 默认 SLOW 模式耗时不超过 25ms</p></li><li><p>逐个遍历 db，逐个遍历 db 中的 bucket，抽取20个 Key 判断是否过期</p></li><li><p>如果没达到时间上限（25ms）并且过期key比例大于 10%，再进行一次抽样，否则结束</p></li></ul><br><p>FAST 模式规则（过期 Key 比例小于10%不执行 ）：</p><ul><li><p>执行频率受 beforeSleep() 调用频率影响，但两次 FAST 模式间隔不低于 2ms</p></li><li><p>执行清理耗时不超过 1ms</p></li><li><p>逐个遍历 db，逐个遍历 db 中的 bucket，抽取 20 个 Key 判断是否过期。如果没达到时间上限（1ms）并且过期 Key 比例大于10%，再进行一次抽样，否则结束</p></li></ul><br><h4 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h4><p>RedisKey 的 TTL 记录方式：</p><ul><li>在 RedisDB 中通过一个 Dict 记录每个 Key 的 TTL 时间</li></ul><p>过期 Key 的删除策略：</p><ul><li><p>惰性清理：每次查找 Key 时判断是否过期，如果过期则删除</p></li><li><p>定期清理：定期抽样部分 Key，判断是否过期，如果过期则删除。</p></li></ul><p>定期清理的两种模式：</p><ul><li><p>SLOW 模式执行频率默认为10，每次不超过 25ms （<strong>高吞吐</strong>）</p></li><li><p>FAST 模式执行频率不固定，但两次间隔不低于 2ms，每次耗时不超过 1ms（<strong>低延迟</strong>）</p></li></ul><br><h3 id="内存淘汰" tabindex="-1">内存淘汰 <a class="header-anchor" href="#内存淘汰" aria-label="Permalink to &quot;内存淘汰&quot;">​</a></h3><p>内存淘汰：就是当 Redis 内存使用达到设置的上限时，主动挑选部分 Key 删除以释放更多内存的流程。</p><blockquote><p>思考：Redis 在什么时候会去检查内存是否充足？</p></blockquote><p>Redis 会在处理客户端命令的方法 processCommand() 中尝试做内存淘汰：</p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-20240315172059388.png" alt="image-20240315172059388" style="zoom:50%;"><br><p><strong>淘汰策略</strong></p><p>Redis支持8种不同策略来选择要删除的key：</p><ul><li>noeviction： 不淘汰任何key，但是内存满时不允许写入新数据，<strong>默认就是这种策略</strong>。</li><li>volatile-ttl： 对设置了TTL的key，比较key的剩余TTL值，TTL越小越先被淘汰</li><li>allkeys-random：对全体key ，随机进行淘汰。也就是直接从db-&gt;dict中随机挑选</li><li>volatile-random：对设置了TTL的key ，随机进行淘汰。也就是从db-&gt;expires中随机挑选。</li><li>allkeys-lru： 对全体key，基于LRU算法进行淘汰</li><li>volatile-lru： 对设置了TTL的key，基于LRU算法进行淘汰</li><li>allkeys-lfu： 对全体key，基于LFU算法进行淘汰</li><li>volatile-lfu： 对设置了TTL的key，基于LFI算法进行淘汰</li></ul><div class="language-properties vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">properties</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># The default is:</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># maxmemory-policy noeviction</span></span></code></pre></div><br><p>比较容易混淆的有两个：</p><ul><li>LRU（Least Recently Used）：最少最近使用。用当前时间减去最后一次访问时间，这个值越大则淘汰优先级越高。</li><li>LFU（Least Frequently Used）：最少频率使用。会统计每个 Key 的访问频率，值越小淘汰优先级越高。</li></ul><br><blockquote><p>思考：Redis 如何知道最近使用的时间和使用的频率？</p></blockquote><p>Redis的数据都会被封装为 RedisObject 结构：</p><p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-20240315172425662.png" alt="image-20240315172425662" loading="lazy"></p><p>LFU 的访问次数之所以叫做<strong>逻辑访问次数</strong>，是因为并不是每次key被访问都计数，而是通过运算：</p><ul><li>生成 0~1 之间的随机数R</li><li>计算 (旧次数 * lfu_log_factor + 1)，记录为P</li><li>如果 R &lt; P ，则计数器 + 1，且最大不超过255</li><li>访问次数会随时间衰减，距离上一次访问时间每隔 lfu_decay_time 分钟，计数器 -1</li></ul><br><p>最后用一副图来描述当前的这个流程吧</p><p><img src="https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-20240315172440910.png" alt="image-20240315172440910" loading="lazy"></p><br><p>使用建议：</p><ol><li>优先使用 allkeys-lru 策略。充分利用 LRU 算法的优势，把最近最常访问的数据留在缓存中。如果业务有明显的冷热数据区分，建议使用。</li><li>如果业务中数据访问频率差别不大，没有明显冷热数据区分，建议使用 allkeys-random，随机选择淘汰。</li><li>如果业务中有置顶的需求，可以使用 volatile-lru 策略，同时置顶数据不设置过期时间，这些数据就一直不被删除，会淘汰其他设置过期时间的数据。</li><li>如果业务中有短时高频访问的数据，可以使用 allkeys-lfu 或 volatile-lfu 策略。</li></ol>`,75),n=[t];function p(r,h,o,k,d,c){return s(),l("div",null,n)}const y=i(e,[["render",p]]);export{g as __pageData,y as default};
