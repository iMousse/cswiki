import{_ as l,c as i,o as p,V as e}from"./chunks/framework.syB9hai_.js";const O=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"src/base/summarize/index.md","filePath":"src/base/summarize/index.md","lastUpdated":1733140857000}'),a={name:"src/base/summarize/index.md"},s=e("<p>线程与进程的区别？</p><ul><li>进程是正在运行程序的实例，进程中包含了线程，每个线程执行不同的任务。</li><li>不同的进程使用不同的存储空间，同一进程下的线程共享内存空间。</li><li>线程比进程更轻量，线程上下文的切换比进程上下文的切换要低。</li></ul><p>并发与并行的区别？</p><ul><li>并发是同一时间应对（dealing with）多件事情的能力。一个 CPU 轮流执行多个线程，宏观上是并行，微观上是串行。</li><li>并行是同一时间处理（doing）多件事情的能力。</li></ul><p>举个例子，食堂阿姨给学生打饭。一个阿姨给两个队伍同时打饭就是并发。两个阿姨同时给两个队伍打饭就是并行。</p><p>创建线程有哪些方式？</p><ul><li>继承 Thread 线程并重写 run 方法，调用 start 启动线程。</li><li>重写 Runnable 的 run 方法，并将 Runnable 类放入到 Thread 类中，调用 start 方法启动线程。</li><li>重写 Callable 的 call 方法，并将 Callable 放入到创建 TaskFuture 中，再将创建的 TaskFuture 类放入到 Thread 类中，调用 start 方法启动线程。并且可以通过 TaskFuture 的 get 方法获取执行结果。</li><li>通过线程池创建对象，调用 sumbit 启动线程，调用 shutdown 关闭线程。</li></ul><p>Runnable 和 Callable 有什么区别？</p><ul><li>Runnable 的 run 方法没有返回值；Callable 的 call 方法有返回值，并且是个范型，可以通过 Future、FutureTask 配合 get 方法获取异步执行的结果。此方法会阻塞主进程继续往下执行，如果不调用则不会阻塞。</li><li>Runnable 的 run 方法的异常只能在内部消化，不能向上抛，Callable 的 call 方法允许抛出异常。</li></ul><p>run 方法和 start 方法有什么区别？</p><ul><li>start 方法用来启动线程，通过线程调用 run 方法中的代码，start 方法只允许调用一次，而 run 方法封装了要执行的代码，可以多次调用。</li><li>start 方法是将线程 NEW 状态切换成 RUNNABLE 状态，调用完 run 方法后线程就从 RUNNABLE 状态切换成了 TERMINATE 状态。</li></ul><p>线程之间的状态是如何切换的？</p><p>JDK中的 Thread 线程中有枚举类型定义了线程的六种状态，分别为：新建，运行，阻塞，等待，有限等待，终结。</p><ul><li>当一个线程对象被创建并调用了 start 方法，线程就会从 NEW 状态进入到 RUNNABLE 状态，当执行了 run 方法，线程就会从 RUNNABLE 进入 TERMINATE 状态。这是一个线程的正常的状态。</li><li>当线程获取锁失败，则会从 RUNNABLE 状态进入 Monitor 的阻塞队列进入到 BLOCK 状态，当持有线程的锁释放以后，就会按照一定的规则唤醒阻塞队列的线程，唤醒后的线程则进入可运行状态去竞争锁。</li><li>当线程获取锁成功，但是由于没有满足条件而调用了 wait 方法，就会将 RUNNABLE 的线程状态切换成 WAITING 。当持有线程的锁调用了 notify 或 notifyall 方法后就会重新竞争锁。如果是调用了带参数的 wait 方法则会在等待时间结束以后等待唤醒后去重新竞争锁。</li><li>还有一种情况就是调用了 Thread.sleep 的带参方法也会将线程从 RUNNABLE 进入 TIMED_WAITTING，并且不需要主动唤醒，时间到了以后就会自然恢复到可运行状态。</li></ul><p>sleep 方法和 wait 方法的相同点和不同点？</p><p>相同点</p><ul><li>sleep 方法和 wait 方法都是将线程的 RUNNABLE 状态切换成 WAITING状态</li><li>都可以清除打断状态</li></ul><p>不同点</p><ul><li>方法归属不同：sleep 方法属于 Thread 的静态方法，wait 属于 Object 的成员方法</li><li>醒来时机不同：sleep 方法和 wait 方法虽然都是等待相应的时间醒来，但是 wait 必须通过notify 进行唤醒，并且 wait 方法不唤醒就会一直等待下去，而 slepp 在等待完时间后就会自动唤醒。</li><li>锁特性不同：wait 方法调用必须获取 wait 方法的对象锁，而 sleep 方法没有这个限制。并且 wait 方法执行后释放对象锁，允许其他线程获取该对象锁。如果 sleep 在 synchronized 代码块中执行，并不会释放对象锁。</li></ul><p>如何终止一个正在运行的线程。</p><ul><li>使用终止标志和关键字 volatile，使线程正常退出，就是让 run 方法执行完成后终止。</li><li>使用线程的 interrupt 方法中断线程，内部其实也是使用中断标记来中断线程。</li><li>使用线程的 stop 方法强行终止，这个方法在 JDK中已经废弃，不推荐使用。</li></ul><p>什么是 Java 内存模型，如何理解？</p><ul><li>Java 内存模型定义了共享内存中多线程程序读写操作的行为规范，通过这些规范来对保证内存的读写操作正常执行。</li><li>Java 内存模型把内存分为私有线程的工作区域，称为工作内存；一块是所有线程的共享区域，称为主内存。</li><li>线程和线程之间的数据是相互隔离的，线程间的通信必须通过主内存。</li></ul><p>导致并发问题的根本原因是什么，如何解决？</p><ul><li>导致并发问题的原因有三个，线程切换带来的原子性问题，编译器优化带来的可见性问题，CPU指令重排带来的有序性问题。</li><li>可见性问题是编译器优化造成的，有序性问题是 CPU 指令重排导致的，可以使用 volatile 关键字来解决。原子性问题是切换导致的，可以使用 CAS 解决，加锁可以粗暴的解决这三种问题。</li></ul><p>关键字 volatile 有什么功能？</p><p>volatile 关键字可以修饰类的成员变量、类的静态成员变量。主要有两个功能</p><ul><li>保证了线程间的可见性：用 volatile 修饰共享变量，能够防止编译器优化，让一个线程对共享变量的修改对另一个线程可见。</li><li>禁止进行指令重排序：用 volatile 修饰变量，变量在读写时会加入读写屏障，阻止其他读写操作越过屏障，达到阻止重排序的效果。</li></ul><p>关键字 synchronized 原理是什么？</p><p>synchronized</p><p>什么是缓存穿透，如何解决？</p><p>缓存穿透是当查询一个不存在的数据，从缓存中查不到数据，每次都去查询数据库，请求太多就会导致数据库崩溃。一般有这种情况都是数据库遭遇到了攻击，一般采用缓存空数据和布隆过滤两种方法。</p><ul><li>缓存空数据实现简单，但是会造成一定的内存浪费，还有可能会导致数据一致性问题</li><li>布隆过滤器占用内存少，没有多余的key，但是有一定的误判。</li></ul><p>布隆过滤器可以通过 Redisson 实现，实现原理是声明一个比较大的数组，里面存 0。在 Key 经过三次 hash 以后，摸于数组长度知道数组下标的数据，从 0 改到 1，三个数组位置标记一个 Key。查找过程同理。所以布隆过滤器会有一定的误判，一般将误判率设置成 5%，低于 5% 需要增加数组长度，但是会对内存产生更多的消耗。</p><p>什么是缓存击穿，如何解决？</p><p>缓存击穿是指一个设置过期时间到 Key，在过期时有大量的请求发送过来。这时候所有的查询都走数据库，从而导致数据库崩溃。我们一般互斥锁和逻辑过期有两种方法解决。</p><ul><li>互斥锁是在缓存失效的时候设置一个互斥锁，只有拿到互斥锁才能重建缓存，在重建缓存期间的请求都会被阻塞，只有重建完成以后才能重新获取缓存数据。</li><li>逻辑过期时给缓存设置一个逻辑过期时间，当缓存要过期时重新开启一个有互斥锁的线程对数据进行重建。在重建的过程中，新线程只能拿到过期的数据，并且因为有互斥锁的缘故，新线程不能重建数据。当数据重建完成后其他线程就能获取到最新数据。</li></ul><p>两种方法各有利弊，互斥锁保证了数据的强一致性，但是性能不高，因为缓存在重建的过程中是无法获取数据的。逻辑过期保证了高可用，性能比较高，保证了数据最终一致性，但是没有保证数据的实时一致性。</p><p>什么是缓存雪崩，如何解决？</p><p>缓存雪崩是指大量 Key 同一时间失效或者 Redis 服务宕机，导致大量的请求直接到达数据库，造成数据库崩溃。</p><ul><li>给不同的 Key 设置随机过期时间。</li><li>利用 Redis 集群提高服务的可用性。</li><li>给业务添加多级缓存</li><li>给缓存业务添加降级策略，降级策略作为系统的保底，适用于穿透、击穿、雪崩。</li></ul><p>你们项目是如何将数据库和缓存数据进行同步的？</p><p>对一致性要求没那么高的，采用异步通知的方式对数据进行通过</p><ul><li>使用 MQ 作为中间件，当服务数据更新以后，通过消息更新将缓存数据更新</li><li>使用 Canal 作为中间件，不需要修改业务代码，伪装成 MySQL 的一个从节点，读取 binlog 日志来将缓存数据更新</li></ul><p>如果是强一致性的，采用 Redisson 提供的读写锁。</p><ul><li>将业务的查询添加共享锁：读锁 ReadLock，加锁后其他线程可用共享读操作。</li><li>将业务的修改添加排他锁：独占锁 WriteLock，加锁后修改会阻塞其他线程的读写操作。</li></ul><p>你听说过延迟双删吗，为什么不用延迟双删？</p><p>延迟双删，如果是写操作，先删除缓存中的数据，然后再修改数据库，延迟一会儿再删除缓存中的数据。其中这个延迟时间不好确定，延迟的过程中也可能会有脏数据，并不能保证强一致性。并且这样的代码编写复杂，不利于对业务代码的理解。所以我们系统没有采用。</p><p>你们项目中的分布式锁是如何实现的？</p><p>我们系统使用的是 Redisson 来实现分布式锁的，底层是 sentx 和 Lua 脚本来实现的。因为 Redis 是单线程的，用了命令之后只能有一个客户端对 Key 进行设置值，当 Key 没有过期或者删除，其他客户端都不能设置这个 Key。</p><p>Redisson 如何实现锁的有效时长？</p><p>Redisson 的锁有一个等待时间和超时时间。当一个锁设置超时时间还没有结束时，会有一个看门狗机制，每隔一段时间就会检查当前业务是否还持有锁，如果还持有锁就增加锁的持有时间，当业务执行完以后就可以直接释放了。</p><p>等待时间可以在高并发的情况下提升性能，当线程发生争抢后不会马上进入阻塞，而是进入自旋操作，尝试获取锁。当抢到的线程释放后，没有抢到的线程就可以尝试重新获取锁。</p><p>Redisson 锁还支持可重入，这是为了避免出现死锁。重入机制就是在尝试重入的时候会判断是否是当前线程持有的锁，如果是当前线程持有的锁就加一，释放锁的时候当前线程持有减一。存储线程数据是 Hash 结构，大 Key 是自己业务锁，小 Key 是线程ID，Value 是线程重入次数。</p><p>Redisson 实现的分布式锁能解决主从一致性问题吗？</p><p>Redisson 无法解决分布式锁的一致性问题。当线程一加锁成功后，从节点还没有从主节点获取到同步的数据就宕机了。这时候从节点就会重新升级为主节点，当这时重新进来一个线程二，就会在新的主节点上重新上锁，这时候就会有两个线程都获取到同一把锁。</p><p>Redisson 提供了红锁解决了这个问题。红锁主要提供了同时在再多个节点上都创建锁成功才能使用锁，解决了由于主从节点数据延迟同步导致的加锁失败问题。但正因为红锁需要同时在多个节点上加锁，性能就会变的很低，维护成本也很高，所以项目中一般不会使用红锁，并且官方也暂时废除了这个红锁。</p><p>如果业务一定要考虑数据强一致性怎么办呢？</p><p>Redis 本身设计就是高可用，做到强一致性就非常影响性能，可以考虑使用 Zookeeper 实现分布式锁来保证强一致性。</p><p>Redis作为缓存，如何实现数据的持久化？</p><p>Redis 持久化数据有两种方式，一种是 RDB ，一种是 AOF</p><ul><li>RDB 是快照文件，定期将内存中的数据同步到磁盘中，当 Redis 宕机需要恢复数据时则通过 RDB 快照文件进行数据恢复</li><li>AOF 是追加文件，将 Redis 执行写操作的命令追加到文件中，当 Redis 宕机需要恢复数据则通过 AOF 文件执行所有记录在文件上的写命令。</li></ul><p>RDB 是一个二进制文件，数据恢复的很快，但是会有丢失数据的风险。而 AOF 丢失数据风险比较小，有灵活的刷盘策略，但是是通过执行命令的方式，所以恢复数据比较慢。在 Redis 4.0 更新了一种混合持久化，结合了 RDB 和 AOF 文件的优点。在 AOF 文件的前半部分包含了一个完整的快照数据，在 AOF 文件的后半部分记录自生成 RDB 文件之后的所有写操作命令，用来提高数据恢复的效率和丢失数据的风险。</p><p>RDB 执行的原理是什么？</p><p>Redis 在执行 bgsave 命令后主进程会 fork 一个子进程来共享内存空间。</p><p>共享的内存空间是通过页表来维护的，页表是维护虚拟内存和物理内存的关系映射，所以子进程拷贝主进程的数据很快，是纳秒级别的。完成 fork 以后子进程会写新的 RDB 来替换旧的 RDB文件。</p><p>fork 采用的是 copy-on-write 技术。当线程来读取数据时，可以读取共享内存的数据。当有写操作，则将共享内存的数据拷贝一份并进行修改，修改完成以后线程则读取最新修改后的数据。</p><p>怎么保证 Redis 的高并发高可用？</p><p>搭建主从节点提升高并发，并使用哨兵模式提升高可用，哨兵模式可以实现主从集群的自动故障恢复，里面就包含了对主从服务的监控、自动故障转移和通知。</p><p>你们项目是采用什么样的集群？</p><p>我们项目当时采用的是一主两从三哨兵。一般单节点不超过10g内存，如果内存不足则可以通过给不同服务分配独立的 Redis 主从节点，尽量不做分片集群。因为分片集群维护起来比较麻烦，成本比较高，并且集群之间的心跳检测和数据通信会消耗大量的网络请求，并且不可以使用 Redis 的事物和 Lua 脚本。</p><p>那你们 Redis 集群脑裂是如何解决的？</p><p>当我们主节点信号不好时，哨兵没有感受到主节点的心跳，这时哨兵就会选取一个从节点来作为新的主节点，这时就存在两个主节点，就像大脑分裂一样。这样会导致客户端还在原先的主节点写数据，新节点无法同步数据。当网络恢复以后，哨兵就会将原先的主节点降为从节点，这时再从新的主节点同步数据，脑裂过程中写入的数据则都会丢失。</p><p>我们可以在 Redis 设置两个参数来解决脑裂问题。一个参数时设置最少的从节点数，必须要有一个从节点才能同步数据。第二个设置主从复制和同步的延迟时间，达不到要求的就拒绝请求，这样就可以避免数据丢失。</p><p>Redis 的数据过期策略有哪些？</p><p>Redis 的数据过期策略有两种，一种是惰性删除，还有一种是定时删除。</p><ul><li>惰性删除是每次查询 Key 时判断是否过期，过期则删除数据。</li><li>定时删除是定期抽样部分 Key 判断是否过期，过期则删除数据。其中定时删除还分为两种模式，SLOW 和 FAST <ul><li>SLOW 是高吞吐模式，默认每秒执行10次，每次不超过 25ms</li><li>FAST 是低延迟模式，执行的频率不固定，但两次间隔不能低于 2ms，每次耗时不能超过 1ms</li></ul></li></ul><p>Reids 的过期策略是两种结合：惰性删除加上定期删除进行配合使用。</p><p>Redis 的数据淘汰策略有哪些？</p><p>Redis 总共提供了八种数据淘汰策略。系统默认的数据淘汰策略是不删除任何数据，内存不足直接报错。还有一种是随机删除的数据淘汰策略。其他的配置有两个重要的概念，一个是 LRU ，一个是 LFU。</p><ul><li>LRU 是最少最近使用，用当前时间减去最后一次访问的时间，这个值越大淘汰的优先级越高。按照最少最近使用有两种数据淘汰策略，一种是所有 Key 按照 LRU 来进行淘汰，一种是只有设置了 TTL 的 Key 按照 LRU 进行淘汰。</li><li>LFU 是最少频率使用，会统计每个 Key 的访问频率，访问频率越低淘汰的优先级越高。按照最少频率使用有两种数据淘汰策略，一种是所有 Key 按照 LFU 来进行淘汰，一种是只有设置了 TTL 的 Key 按照 LFU 进行淘汰。</li></ul><p>还有两种淘汰策略就是对设置了 TTL 的 Key 进行随机淘汰，对设置了过期时间的 TTL，比较 TTL 的剩余值，TTL 越小越先被淘汰。</p><p>那你们系统中的数据淘汰策略是如何使用的？</p><ul><li>如果系统中没有冷热数据的区分，访问频率差别不大，则建议使用 allkeys-random，随机选择淘汰。</li><li>如果系统中有冷热数据区分，则建议使用 allkeys-lru，把最近访问的数据留在缓存中。</li><li>如果系有短时高频的数据，则使用 allkeys-lfu</li><li>如果业务中有指定的需求，置顶的数据不过期删除，则可以使用 volaitle-ttl，只对设置 TTL 的 Key 进行删除。</li></ul><p>Redis 是单线程的，但是为什么还那么快？</p><ul><li>Redis 是基于内存的数据库，内存的读写速度非常快。</li><li>执行命令采用单线程，避免不必要的上下文切换。</li><li>使用多路 IO 复用模型，这种技术允许单个线程同时处理多个IO操作，单个IO操作的阻塞不会影响其他IO操作。这种IO操作提高了IO操作的效率，使得 Redis 能够在高并发环境下保持高性能‌</li></ul><p>JVM有什么特性？</p><p>JVM 最大的特性是跨平台，对于 C/C++ 语言来说会将源代码编译成 CPU 能够识别的机器码来执行，不同的系统需要重新编译连接。而 Java 语言通过 Javac 将源文件编译成字节码之后，可以通过不同平台的 JVM 将字节码文件实时解释成机器码文件。并且 Java 还是半编译半解释型语言。也可以通过执行引擎的编译器将热点代码进行优化，直接转变为机器码。</p><p>JVM实现了哪些功能？</p><ul><li>解释与运行：通过执行引擎的解释器将字节码实时解释成CPU能够执行的机器码</li><li>即时编译：通过执行引擎的编译器将热点代码进行优化，将字节码直接转化为机器码放在方法区中存储，提高执行效率。</li><li>内存管理：通过运行时数据区自动的为对象、方法分配内存空间，通过执行引擎的垃圾回收器自动实现垃圾回收。</li></ul><p>JVM由哪些部分组成，如何运行？</p><p>JVM 主要由类加载器，运行时数据区，执行引擎，本地库接口组成。Java 源文件通过 Javac 将源代码编译成字节码，然后通过类加载器子系统加载到内存中，然后通过运行时数据区将加载到内存中的字节码自动分配内存。通过执行引擎的解释器将字节码翻译成机器码，在交由 CPU 去执行。如果调用了 C语言，这时就需要调用本地接口。</p><p>请详细说明一下 JVM 运行时数据区？</p><p>运行时数据区可以分为线程共享区和线程私有区。</p><ul><li>线程共享区有堆和本地内存，堆是主要数据存储的地方，存储对象和数组。是垃圾回收器管理的主要部分。本地内存不是虚拟机运行时数据区的一部分，是虚拟机直接向系统申请的内存区域，包含了方法区和直接内存。方法区是存放类的信息，常量、方法、字段、静态变量、即时编译优化后的代码。直接内存常用于 NIO 操作，用于数据缓冲区，分配成本高但是读写性能也高。</li><li>线程私有区有虚拟机栈，本地方法栈，程序计数器。虚拟机栈是程序运行的地方，里面存储的是栈帧，栈帧里面存储的是局部变量表、操作数栈、动态链接、方法出口等。本地方法栈与虚拟机栈功能相同，区别是本地方法栈是 Java 调用非 Java 代码的接口。程序计数器存放的是当前线程所执行字节码的行数。</li></ul><p>能给我详细介绍一下方法区吗？</p><ul><li>方法区是各个线程共享的内存区域，与直接内存一起存储与本地内存中。</li><li>主要存储的是被虚拟机加载类的元数据信息。包括类的结构、方法、字段、常量，即时编译器优化的代码。</li><li>在 JDK7 方法区称为永久代，并且数据放在堆中，如果加载类数据太多很容易导致 OOM。在 JDK8 中就将方法区的实现放在了本地内存的元空间中，将字符串常量放入了堆中。这样元空间的大小就不受 JVM 限制，并且不需要GC，提升了性能。</li><li>如果方法区中无法存放，则会抛出 <code>OutOfMemoryError:Metaspace</code></li></ul><p>字符串常量池和运行时常量池有什么关系？</p><p>字符串常量池是存放于 JVM 的堆中，用于存储<mark>创建对象时</mark>的字符串的字面量引用，主要是为了避免程序<mark>在运行时</mark>创建大量内容相同的字符串对象，从而节省内存和提高性能‌。</p><p>运行时常量池是存放于方法区中，用于存储符号引用和字面量，在编译时就确认了。当类被加载到 JVM 中时，class文件中的常量池内容会被加载到运行时常量池中。</p><p>能给我详细介绍一下 Java 堆吗？</p><p>Java 堆是线程共享的区域，主要存储对象和数组，是垃圾回收器主要工作的地方。内存不足会报 <code>OutOfMemoryError:Java heap space</code>。</p><p>主要由年轻代和老年代构成。年轻代有伊甸园区，From区和To区，存放一些年轻的对象；老年代存放的是一些大对象或年老的对象。</p><p>什么是虚拟机栈</p><p>每个线程运行所需要的内存，称为虚拟机栈，遵循后进先出原则。并且每个栈由多个栈帧组成，对应着方法每次调用所占的内存，活动栈帧只有一个，对应着正在执行的方法。</p><p>堆和栈的主要区别是什么？</p><p>最本质的区别堆是存储单位，存储对象和数组；栈是运行单位，运行时调用局部变量和房变量。</p><p>栈的生命周期比较短，随着方法的入栈出栈终结；而堆的生命周期比较长，知道被垃圾回收器回收。</p><p>栈内存是线程私有的，堆内存是线程共享的。当栈空间不足时报 StackOverFlowError，堆内存不足时报 OutOfMemoryError</p><p>什么是类加载器，类加载器有哪些？</p><p>类加载器将字节码文件加载到 JVM 中，让 Java 程序能够运行起来。常见的类加载器由四个</p><ul><li>引导类加载器，是最顶级的加载器，由 C++ 编码实现，主要加载 JAVE_HOME/jre/lib 目录下的库类。</li><li>拓展类加载器，是引导类加载器的子类，由 Java 编码实现，主要加载 JAVE_HOME/jre/lib/ext 目录下的库类。</li><li>应用类加载器，是拓展类加载器的子类，由 Java 编码实现，主要加载 Classpath 下的类，也就是自己编写的 Java 类。</li><li>自定义类加载器，开发者自定义类继承 ClassLoader，实现自定义加载规则。</li></ul><p>什么是双亲委派机制，为什么使用这个机制？</p><p>如果一个类加载器收到了类加载的请求，首先不会自己去加载，而是把请求给父类加载器，而且每个层级的类加载器都是这个规则。所以最终类的加载都要到顶层的引导类加载器来加载，只有引导类加载不了这个加载请求，子类加载器才会尝试自己去加载。</p><p>使用双亲委派机制可以防止 Java 核心库的 API 被篡改，而且可以避免一个类被重复加载。</p><p>那你知道类加载器的执行过程吗？</p><p>类从加载器加载到虚拟机中，生命周期包括了加载、连接、初始化、使用、卸载。其中连接分为了验证、准备、解析。</p><p>首先将类加载到虚拟机中，然后验证来保证加载类的正确性，准备阶段为类分配内存，并设置类变量的初始值，解析阶段将类中的符号引用转化为直接引用。初始化阶段对类的静态变量和静态代码块执行初始化操作。使用就是对 new 完的类进行调用，当数据为空后没有引用关系则将类进行卸载。</p><p>能介绍一下垃圾回收器的主要功能吗？</p><p>垃圾回收器的主要功能是自动回收不再使用的对象，以防止内存泄露，并优化内存使用，从而保证程序稳定的运行。</p><p>基本功能</p><ul><li>内存分配：当程序创建对象时，垃圾回收器会在堆内存中找到足够的空闲空间来存储这些对象。</li><li>垃圾回收：自动检测并回收不再被程序引用的内存区域，确保系统资源有效利用，防止内存泄露。检测垃圾的算法有两种，引用器计数法和可达性分析算法，引用器计数法没法解决循环引用的依赖问题，所以 Java 使用的是可达性分析算法。</li><li>系统稳定：通过定期进行垃圾回收，避免系统长时间运行的程序占用内存时间过长导致的系统资源耗尽和性能下降问题。</li><li>简化编程：消除了手动管理内存的复杂性，使得开发者可以更专注业务逻辑实现，不需要关注内存分配和释放的细节。</li></ul><p>强引用，软引用，弱引用，虚引用各有什么区别？</p><ul><li>强引用是普通的引用方式，表示一个对象处于有用且必须的状态，即使内存不足也不会回收</li><li>软引用表示一个对象处于有用且非必须的状态，会在内存不足的时候进行回收。</li><li>弱引用表示一个对象处于可能有用且非必须的状态，在 GC 时就会被回收。</li><li>虚引用表示一个对象处于无用状态，任何时候都会被回收。</li></ul><p>垃圾回收算法有哪些？</p><p>垃圾回收算法主要包含标记清除算法，标记整理算法、复制算法、分代收集算法</p><ul><li>标记清除算法将垃圾回收分为标记阶段和清除阶段，标记阶段从根结点开始，标记所有可达对象，在清除阶段清除所有没有被标记的对象。效率高，但是有磁盘碎片，内存不连续。</li><li>标记整理算法分为标记，清除，整理三个阶段，会将标记清除后存活的对象移动到内存另一段。相比于标记清除算法，效率低，但是没有磁盘碎片，内存连续。</li><li>复制算法将内存分为两块，每次只使用一块。在垃圾回收时，将存活的独享复制到另一块内存中，然后清除当前块的内容。虽然没有磁盘随盘，但是造成了内存浪费，回收效率高于标记整理算法但是低于标记清除算法</li><li>分代收集算法根据对象的生命周期内存划分为年轻代和老年代，并根据各代的特征采用最合适的收集算法。</li></ul><p>详细说明一下分代收集算法？</p><p>JDK8版本时，堆被分为了两个部分，一个是新生代，一个是老年代，默认空间占用比例是1:2</p><p>新生代内部又被分为三个区域。伊甸园区，FROM区和TO区。默认空间占比为8:1:1</p><p>具体的工作流程是这样的：</p><ul><li>新创建的对象先放到伊甸园区，当伊甸园区和 FROM 区满时会触发 YoungGC，将存活对象采用复制算法复制到 TO区 并年龄加一，复制完成后伊甸园区和FROM区都会释放内存，并把TO 区改为FROM 区。</li><li>当经过一段时间内存又不足时触发 YoungGC，重复上面的步骤，当TO 区存活的对象超过15岁后则晋升为老年代。如果幸存区内存不足或大对象会提前晋升为老年代。</li><li>当老年代满了以后会触发FullGC，同时收集年轻代和老年代，这时是只存在FullGC的线程执行，其他线程都会被挂起。我们需要在程序中尽量避免FullGC出现。</li></ul><p>垃圾回收器有哪些，你们项目时如何选择的？</p><p>垃圾回收器按照工作模式划分可以分为串行垃圾回收器，并行垃圾回收器，并发垃圾回收器。</p><ul><li>串行垃圾回收器：Serial 用于新生代，使用复制算法。Serial Old 作用于老年代，采用标记整理算法。在垃圾回收时，只有一个线程在工作，其他线程都需要停下来等待垃圾回收的完成（STW）。适用于内存堆比较小的个人电脑，是 JDK 在 Client 模式下默认使用的垃圾回收器。</li><li>并行垃圾回收器：Parallel Scavenge 作用于新生代，采用复制算法。Parallel Old 作用于老年代，采用标记整理算法。在垃圾回收时，有多个线程在工作，并且其他线程都需要停下来等待垃圾回收的完成。是吞吐量优先的收集器，是 JDK在 Server 模式下默认使用的垃圾回收器。</li><li>并发垃圾回收器：Parallel New 作用于新生代，采用复制算法。CMS 作用于老年代，采用Serial Old作为备用，采用标记清除算法。是一款响应时间优先的收集器，停顿时间短，用户体验好。但是由于无法处理浮动垃圾，所以需要使用 Seiral Old 作为备用。并且由于浮动垃圾的存在，还会导致频繁的 Full GC，从而导致更大的时间停顿。从 JDK9 开始将 CMS 标记为过时，并且默认使用了 G1 垃圾回收器。</li></ul>",135),u=[s];function r(t,o,d,n,R,T){return p(),i("div",null,u)}const J=l(a,[["render",r]]);export{O as __pageData,J as default};
