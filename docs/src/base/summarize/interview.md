# 面试准备篇


[返回首页](index.md)

面试题，简历，学习效率



STAR——挑战+解决方案的表达方式

框架
Situation背景
Task 任务
Action 行动
Result 结果-

重点：
①可以把自己的成就有条理的说清楚
②不一定要执着顺序，也可以先说R



需要优化的点：

1.专业技能要写详细

2.工作经历的工作描述

3.项目经理的技术点，如何实现的具体描述

4.不同的公司要给不同的侧重点，需要修改





## 职位要求

![image-20231211114219414](https://mugrain.oss-cn-hangzhou.aliyuncs.com/cswiki/image-20231211114219414.png)



岗位职责： 

我们致力于为开展同城零售业务的企业，打通全渠道的交易链路、提供软硬件结合的智慧门店解决方案，提高门店经营的坪效与人效，完善门店数字化建设；同时，也致力于提供线上线下一体化的会员运营系统、场景化的智能营销系统、重视赋能与自驱动的导购系统，帮助门店实现消费者增长。



 我们面临哪些挑战？ 

- 业务复杂度：我们需要以一套门店经营产品，提供通用的商业SaaS解决方案。在这里，你所做的远不止是一个经营管理工具，更要为不同行业的商家赋能，并使其实现增长。
- 架构复杂度：行业内企业级SaaS架构的先驱。不仅需要具备传统的企业级架构经验，完成各种门店复杂场景的流程抽象与建模，更需要进一步地对能力做归纳和抽象，从而实现能力的开放与扩展。 
- 技术复杂度：线下无网、弱网等极端场景下的交易稳定性与资金安全保障，大规模海量数据的批处理，大量微服务场景下的分布式一致性问题。 
- 门店数字化：需要分析和沉淀门店可数字化的场景、指标、维度，通过软硬件结合的方式完成线下各场景的数字采集，并打造精准的归因系统，助力商家进行精细化的分析与决策。
- 综合能力：需要具备一定的商业思维、数据驱动、归因分析的能力。



 工作内容： 

1.在门店交易、智能硬件、会员运营、智能营销、门店导购等业务域，深度参与产品需求讨论，主导或深度参与领域建模、技术方案设计以及系统研发； 

2.主导或深度参与各种疑难杂症的攻坚，包括但不限于：门店交易核心链路的稳定性与安全防控、大批量任务的调度与执行策略、快速提升系统核心业务场景的质量等； 

3.深度参与团队研发流程以及规范的讨论、制定和执行，提升团队的专业程度与研发效率； 

4.主导或深度参与技术分享和技能培训，增强团队的技术氛围，提升团队战斗力和个人影响力。



 任职条件：

1.三年以上研发经验，精通Java基础，熟练掌握JVM、多线程、Java并发等技能 

2.熟练掌握分布式技术栈（框架、消息、调度、存储、缓存等)； 

3.具备一定的领域建模和抽象思维能力，熟悉常用的设计模式与应用场景；

4.具备一定的运维能力，包括但不限于：性能分析与调优、业务与系统指标监控及治理等；

5.对业务有一定的敏感度和前瞻性，乐于用技术驱动业务，并从业务价值中获取成就感；

6.具备跨小组的协作沟通和项目管理能力，能够用专业度和正能量来影响周边的人； 



加分项：

1. 有门店交易、会员运营、智慧门店软硬件整体解决方案等从业经验的优先； 
2. 对新零售或SaaS行业的现状及发展有思考、有行业工作经验的优先； 
3. 有复杂业务的分布式系统设计与研发经验的优先；
4. 具有较强的系统思考性能力、商业思维的优先。



技术方面：在工作时认真负责，处事细心负责，并且有团队合作精神，当有不懂的问题会虚心请教，当然别人有不懂的问题我在知道的情况下也耐心解答。

业务方面：在工作之外我会合理安排时间，学习提升自我。查看Github上的热门项目，有时也会Gitee上看一些国内热门的开源项目，看掘金上的一些技术分享，并且也在尝试自己写一些技术分享的文章。

为人方面：本人热情随和，活泼开朗，善于与人沟通。





1.扎实的编程基础，精通Java基础，熟练掌握JVM、Java并发、网络编程等技能 

2.熟练掌握分布式技术栈：框架、消息、调度、事务、缓存； 

3.有中大型项目的设计经验，熟悉常用的设计模式，能用技术手段解决业务需求；

4.具备一定的运维能力，包括系统的发版与部署、问题的排查与解决、性能的分析与调优



扎实的编程基础，精通Java基础，熟悉掌握JVM，内存模型，并发编程

熟练掌握分布式技术栈：框架、消息、调度、事务、缓存

有中大型项目的设计经验，能有效的利用技术手段解决业务需求。

具备一定的运维能力，包括系统的发版与部署、问题的排查与解决、性能的分析与调优、业务与系统指标的监控





## 专业技能

需要从基础知识，设计模式，常用框架，分布式解决方案，

- 具有扎实的编程基础，精通Java基础，熟悉掌握JVM，内存模型，并发编程
- 可以灵活运用设计模式，如：单例、工厂、策略、责任链、模板方法等设计模式进行项目开发
- 熟悉分布式常见解决方案：分布式事务、分布式一致性、分布式锁
- 有高并发、高性能、高可用系统架构设计实践、并有性能调优经验。
- 深入理解MySQL事务、锁、索引实现机制，可以根据执行计划优化SQL。
- 深入理解Redis线程模型以及Redis的核心数据结构和使用场景，熟悉多级缓存框架。
- 熟练运用Freemarker模板技术和Nginx反向代理服务器
- 熟练运用RabbitMQ、Kafka等主流消息中间件 。
- 熟练运用git、Linux操作系统等基本命令。



## 项目经历

- 负责与客户进行业务交流，精准把握并转化需求，确保设计方案满足业务目标并高效实施。

- 针对系统性能瓶颈，如批处理时长及SQL查询效率问题，进行优化调整，提升系统运行效率。

- 积极响应并解决生产环境中的关键技术问题，如核心扣款失败等，保障系统稳定运行。

- 深入研究业务流程，撰写并维护接口文档，为系统功能模块的设计与实施提供准确指导。

- 主导财富平台信托的研发及定制化开发工作，并按照计划完成工作，确保项目按时高质完成。

- 持续跟踪最新技术动态，推动技术创新和产品升级，增强公司在行业内的竞争力。



## 工作经历

- 项目个数以自己的工作经历为准，时间比较久的可以只写标题或不写。

- 项目要体现业务深度或技术深度

- 有没有主导设计过某个模块开发

- 尽可能展示数据指标（如：达到了多少QPS，达到了多少的数据量）

  - 理财销售系统：服务器的分布

    - 额度模块和账单功能。
    - 主导了关于额度模块的开发。由于监管限制基本贵州银行这种城商行的理财规模，所以需要对理财产品的规模进行控制。但是由于代销和分销的控制逻辑不通所以会导致。额度模块的高可用。redis采用了哨兵模式，并且代销消费了额度会通过kafka发送消息到分销。
    - 电子账单分库分表
    - 核心交易表的分库分表，数据量。
    - 解决生产上死锁导致的交易超时问题
    
  - 代销理财子：主导了理财子跑批模块的建设，实现了兴业银行和贵州银行基于中登2.1的理财文件跑批文件的交互。
  
  - 信托：核心解冻扣款，核心查证，批量差错处理，
  
  - 信创：报表优化，将原跑批慢的，分片表
  
  - 1.建表需要变更。
    	需要根据表判断表是 复制表，还是分片表（现阶段考虑使用客户号做分片，所有涉及客户的表均做分片）
    2.sql变更
            管理台、后台需要检查sql的语法兼容性（如果数据库可以选择oracle兼容模式，那么修改点会少）
    	某些功能如果sql里涉及到join条件不涉及客户号的，且不是复制表的，需要修改（增加客户号做关联条件。或不使用sql join，该为使用程序填充）。
    3.清算需要做分片改造的功能。
    	TA账户类确认（T0，TN）
    	TA交易类确认（T0，TN）
    	份额账户状态交收
    	批量还款、解冻数据生成
    	系统收市效验
    	认购、申购解冻并扣款
    	销售服务清分（此步骤需要看是否计提到每笔交易或客户上的。如果是也需要改造）
    	TN申请文件导出
    	批量还款、解冻数据处理。
  




### 贵州银行理财销售系统

项目描述：为银行的企业客户、零售客户提供理财销售渠道的系统，支持行内各种理财产品销售的业务，辅助产品管理用户进行产品设置，辅助销售管理用户进行销售控制。提供外围渠道的统一接口，与资管系统进行产品和产品份额的数据对接，核心账户扣款还款自动处理。主要功能有产品管理，交易管理，清算管理，到期管理，营销管理，报表查询，额度管理，差错处理。

责任描述

主导产品额度模块的开发，并且通过消息队列的流量削峰解决了代销额度是缓存，分销额度是数据库而导致的额度处理效率不一致的问题。通过对业务进行调研，设计并完成了T0现金类产品的编码和垫资户金额交互，T1现金类产品的改造和T0.5的现金类产品还款。将生产上的SQL进行批量的优化和线上的性能优化，将代码逻辑改为SQL和临时表减少内存计算和磁盘的读写的方式将系统原有对千万级别数据量的确认导入批量时间缩短了3倍。



### 贵州银行理财信创改造

为支撑金融数字化转型，贵州银行启动理财销售系统国产化改造。项目采用行内采购的GoldenDB分布式数据库，改造覆盖交易、跑批、后台管理、监管数据报备及数据报表等核心模块，并同步制定数据迁移方案与脚本。同时，将原有基于哨兵模式的Redis缓存系统迁移至分布式架构，以提升系统整体性能。

责任描述

- 制定改造计划表将工作模块细化，将每个任务按照难易程度分配开发人员并追踪任务完成情况
- 对组员提出的业务上疑难问题进行解答，对技术上的问题提出解决方案或本人进行解决并记录。
- 在周例会与领导汇报每周工作完成情况，项目进度和下一周工作计划，对解决的疑难问题进行汇报。
- 对信创改造中涉及的兼容问题进行改造，比如序列号使用问题，数据类型转换问题，缓存改造为分布式。





### 天府银行商业养老系统

商业养老金系统是向客户提供养老管理、养老规划、资金管理的系统。渠道端主要功能有商业养老金账户开户、销户、产品购买、赎回等交易功能。管理台可支持维护商业养老计划、产品基本参数、锁定账户最低购买比例设置、交易手续费率、黑白名单、文件管理、额度控制、浮动盈亏计算、资金划拨、查询报表等功能，使养老保险公司和商业银行的文件传输通过深证通进行交互。

责任描述：

根据产品 UI 图实现页面的布局，使用自定义指令实现埋点功能，完成手机SDK购买和用户交易回溯，调通后台接口功能，完成对核心接口和协议文件的配置化，并将用户的交易通过批量发送对端，完成一整个链路功能。



### 开科唯识财富7.1平台

财富平台是公司战略级产品，将原有的理财代销、基金代销、基金投顾、贵金属等系统共有的客户功能，产品功能抽象出来，构建成账户中心，公共中心等中台能力中心，个子系统均可作为独立系统进行部署。采用了分布式架构，多运营中心模式，构建基础能力等中心在不同产品间复用，避免系统功能的重复建设。系统采用了SpringCloud + Nacos + Redis + XXL-Job + Kafka + ELK 日志收集。

责任描述

- 主要负责信托和基金的项目功能开发和进度的掌控
- 对接客户需求，对产品不同的定制化功能进行需求评审
- 一周两次代码会议，对小组成员的功能代码进行 review



自我介绍
--------

我从开科入职已五年有余，在这期间做了贵州理财代销系统，代销系统的信创改造，天府银行商业养老保险，目前在公司研发部门负责财富平台7.1的研发。

在贵州银行理财系统期间我工作是 Java 开发，主导产品额度模块的开发，并且通过消息队列对购买额度处理进行流量削峰，将购买的 TPS 提升了 20%。设计并完成了现金类产品的上线，包括 T0 ，T1，T+0.5 的现金类产品，帮助贵州银行实现了理财规模的增长。解决生产问题，比如赎回超时，确认批量跑批时间过长，通过多线程和代码优化将系统原有的确认导入批量时间缩短了3倍。

在理财信创改造阶段我主要的角色是项目经理，负责制定改造计划表将工作模块细化，将每个任务按照难易程度分配开发人员并追踪任务完成情况。对组员提出的业务上疑难问题进行解答，对技术上的问题提出解决方案或本人进行解决并记录。在周例会与领导汇报每周工作完成情况，项目进度和下一周工作计划，对解决的疑难问题进行汇报。对信创改造中涉及的兼容问题进行改造，比如序列号使用问题，缓存改造为分布式，SQL 语法兼容和优化，对分片表进行合理的设计，对进行设计分片表的批量进行优化。

在天府银行商业养老系统我的主要角色是全栈工程师，我主要根据产品 UI 图实现页面的布局，使用自定义指令实现埋点功能，完成手机SDK购买和用户交易回溯，调通后台的交易接口，完成对核心接口和协议文件的配置化，并将用户的交易通过批量发送对端，完成全链路功能。

在公司财富平台7.1我的主要角色是组长，对公司基础研发代码上做二次开发和定制功能。实现了信托的核心交易功能，比如核心交易的分布式事务，核心冻结，超时查证，批量处理，批量差错处理，形成业务闭环。对接现场客户需求，对产品不同的定制化功能进行需求评审并对组员的代码进行评审。在项目现场对项目进行前期部署和运行，将研发产品与现场适配，目前实施了吉林银行信托和吉林农信银行信托，并已成功上线。



## 面试提问

### 理财销售

#### 额度模块

原有的购买交易是通过代销走向分销两个系统，代销购买额度用的是缓存，而分销用的购买是通过扣减数据库，当交易量起来以后，真正限制购买交易瓶颈的是数据库，所以我们引入了消息队列来进行流量削峰来提升系统性能。当然也不用担心分销的额度问题，因为如果额度不充足，在代销的额度扣减都会过不来。





#### 现金产品

现金产品我总共做了两种，一种是 T0 的，可以实时申购和赎回，一种是 T1，都会隔一天购买确认和赎回，但是 T0.5 是 T1 的变种，主要是在赎回的时候在下一日的中午赎回，而不是在晚上赎回，所以又称 T0.5。 T0 产品和 T1 产品主要的不同就是 T0 产品的扣款模式是日间扣款，日末冻结。在工作日购买的时候会将客户的钱实时扣减到归集户。而赎回的时候在行内的垫资户里将钱汇入到客户账，垫资户将在下一日获取到垫资收益。



#### 确认导入

确认导入业务上分为两步，第一步是将协议文件从文件中读取到数据库中。第二步是将读取的协议数据与本地数据做对比，如果交易确认的数据正确则将数据正确处理。

第一步原先是通过全量数据导入的方式，数据量过大以后新能就造成了瓶颈。我们使用了 CountDownLatch 来对 1W 条数据进行分页，提升数据导入的性能。

第二步则是将代码逻辑改为SQL和临时表结合的方式减少内存计算和磁盘读写，将系统原有对千万级别数据量的确认导入批量时间缩短了3倍。



线程池有哪些参数



#### 超时问题 

在生产上隔几个星期就会出现一笔赎回交易超时的数据，我们在查看赎回交易代码后发现未将查询客户份额`SELECT ... FOR UPDATE`语句放在**编程式事务**中管理，当 for update 和 下面的编程式事务存在时差后，其他事务抢占行锁就会导致后续的 update 语句阻塞从而导致超时。正确的做法应该将 for update 写在编程式事务中。



### 信创改造





#### 序列号改造

信创的序列号改造根据不同业务场景选择了不同的方案，比如对于原先协议文件数据是没有主键的，但换了数据库以后必须强制要求主键，对于这一种我们采用了自增的方案。

当时我们想使用美团开源的 Leaf 来解决分布式环境下的全局 Id 生成问题，一种雪花模式生成全局唯一 ID 来当我们的全局流水号，一种号段模式来通过获取连续 Id 来当我们的资金流水号。但是由于我们是理财系统，全局流水号通过渠道生成，资金流水号通过核心生成，并且美团 Leaf 还需要额外组件来支持，所以我们选择通过查询数据库一次生成一批序列加载到 Redis，可以降低数据库压力【减少磁盘 IO 和连接数消耗】，虽然 Redis 宕机会导致序列号丢失，但是我们交易流水号可以不是连续的流水，业务上可以容忍。并且相比于开源 Leaf 的实现，自己实现可以灵活控制。

**具体方案**

我们通过 Redis List 来获取 ID，当为空时，则通过数据库来获取最大 Id 和步长，更新数据库并将数据存储到 Redis List 中。

当 ID 为空时，我们会通过阻塞式同步加载批次号，通过 synchronized 和业务类型 intern 方法，并且使用双重检查来避免重复初始化来提升性能。然后通过 jdbcTemplate 手动开启事务，查询最大id 和步长，通过 for update 分布式锁的形式，更新完数据以后，将 List 加载到 Redis 中。我们选择 Redis 的 List 数据是因为可以提前将数据加载到 List 中。当 ID 不为空时，我们通过异步的方式来补充 ID，当 List 中的数据低于水位线以后，我们会通过 CompletableFuture.runAsync 异步加载批次，通过 ConcurrentHashMap 的 putIfAbsent 方法防重来将 List 加载到 Redis 中。

我们还通过定时任务来增强容错处理，当 Redis 的最大值和数据库中的记录相近时，我们进行提前加载。并且使用本地自增来作为降级方案。



**分布式锁有哪些方案，为什么选择 for update 来作为你的分布式锁？**



#### 分布式缓存

我们从原先的哨兵模式的缓存改变成集群模式，我们通过 Lua 脚本来操作多级额度就会有事务问题。因为多个 Key 会存在插槽不一致的情况。虽然通过花括号可以使得数据在指定插槽，但这也会导致数据倾斜和改造量过大问题。所以我们将额度多级处理取消，然后修改 Lua 脚本仅支持单个 Key 的修改。 



哨兵模式是如何选举的



集群的脑裂是如何产生的，如何避免



集群模式相对于哨兵哨兵模式有什么劣势？

虽然分片集群解决了海量数据存储和高并发写问题，但是大量的分片会造成网络请求的浪费，并且运维的维护成本升高。还要保证插槽不会数据倾斜，所以使用的成本是很高的。



### 财富平台

#### 分布式事务

在财富系统，我们将理财、基金、信托等系统共有的客户功能，产品功能抽象出来，构建成账户中心，产品中心，各个子系统都能分别部署。所以我们系统在购买交易和客户交易时就都需要使用到分布式事务。就比如购买交易，我们选择了性能更加好，但是代码侵入高的 TCC 模式来实现。在修改客户信息，我们用到了本地消息表的方案来实现。在客户份额确认后赠送积分我们则使用消息队列来实现事务的最终一致性。

空回滚是我们没有执行 try 阶段就直接执行了 cancel 阶段，我们需要判断出空回滚。事务悬挂是空回滚执行完以后，事务又重新执行了 try 阶段，而因为执行了 cancel 阶段会导致事务一直处于中间状态。我们需要判断如果已经空回滚了就不能执行 try 操作。并且我们还需要数据的幂等操作。

当我们接收修改客户信息时，我们用到的本地消息表，我们在客户中心会修改客户的信息，并且会插入一条消息日志进入数据库。然后我们系统会有一个定时任务来发送消息，交易服务收到消息以后对客户进行修改。因为可能存在消息发送超时但是消费成功，所以我们要保证操作的幂等。

当我们客户份额确认后给客户中心发送赠送积分为什么不采用本地消费表，是因为我们考虑到如果我们插入本地消息表失败就会导致客户份额确认失败，这是我们不允许的。使用消息队列是相当于一个一个事务最终一致性。积分接收的失败也不会影响上游的本地事务，通过补偿机制和幂等性处理，不断的重试来最终完成任务。





